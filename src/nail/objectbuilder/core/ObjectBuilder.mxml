<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////////////
// 
//  Copyright (c) 2014 <nailsonnego@gmail.com>
// 
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////////
-->

<nail:NailApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					  xmlns:s="library://ns.adobe.com/flex/spark" 
					  xmlns:mx="library://ns.adobe.com/flex/mx"
					  xmlns:nail="library://ns.nail.com/naillib"
					  xmlns:otlib="library://ns.nail.com/otlib"
					  xmlns:controls="nail.otlib.components.controls.*"
					  width="800"
					  height="600"
					  maximizable="false"
					  resizable="false"
					  backgroundColor="0x494949"
					  showStatusBar="false"
					  closing="applicationClosingHandler(event)">
	
	<nail:layout>
		<s:HorizontalLayout gap="3"/>
	</nail:layout>
	
	<fx:Declarations>
		<fx:XMLList id="menuXML">
			<menuitem label="File">
				<menuitem label="New" data="fileNew" icon="nail.objectbuilder.core.Icons_NEW_FILES"/>
				<menuitem label="Open" data="fileOpen" icon="nail.objectbuilder.core.Icons_OPEN"/>
				<menuitem label="Compile" data="fileCompile" icon="nail.objectbuilder.core.Icons_SAVE"/>
			</menuitem>
			<menuitem label="Edit">
				<menuitem label="Auto Save Changes" type="check" data="editAutosave"/>
			</menuitem>
			<menuitem label="Window">
				<menuitem label="Open Log Window" data="windowOpenLog" icon="nail.objectbuilder.core.Icons_LOG"/>
			</menuitem>	
			<menuitem label="Help">
				<menuitem label="About Object Builder" data="helpAbout" icon="nail.objectbuilder.core.Icons_INFO"/>
			</menuitem>	
		</fx:XMLList>
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.events.MenuEvent;
			import mx.managers.DragManager;
			
			import spark.events.IndexChangeEvent;
			
			import nail.codecs.ImageCodec;
			import nail.codecs.ImageFormat;
			import nail.components.NailMain;
			import nail.components.controls.Alert;
			import nail.loaders.BitmapLoader;
			import nail.managers.PopUpWindowManager;
			import nail.objectbuilder.commands.ChangeThingCommand;
			import nail.objectbuilder.commands.CommandType;
			import nail.objectbuilder.commands.CompileAssetsCommand;
			import nail.objectbuilder.commands.CreateNewFilesCommand;
			import nail.objectbuilder.commands.DuplicateThingCommand;
			import nail.objectbuilder.commands.GetSpriteListCommand;
			import nail.objectbuilder.commands.GetThingCommand;
			import nail.objectbuilder.commands.ImportSpriteCommand;
			import nail.objectbuilder.commands.ImportThingCommand;
			import nail.objectbuilder.commands.LoadAssetsCommand;
			import nail.objectbuilder.commands.NewThingCommand;
			import nail.objectbuilder.commands.RemoveSpritesCommand;
			import nail.objectbuilder.commands.RemoveThingCommand;
			import nail.objectbuilder.commands.ReplaceSpriteCommand;
			import nail.objectbuilder.settings.ObjectBuilderSettings;
			import nail.otlib.assets.AssetsInfo;
			import nail.otlib.assets.AssetsVersion;
			import nail.otlib.components.controls.CompileAssetsWindow;
			import nail.otlib.components.controls.CropImageWindow;
			import nail.otlib.components.controls.ExportWindow;
			import nail.otlib.components.controls.ImportThingWindow;
			import nail.otlib.components.controls.LogWindow;
			import nail.otlib.components.controls.NewAssetsWindow;
			import nail.otlib.components.controls.OpenAssetsWindow;
			import nail.otlib.events.ThingEditorEvent;
			import nail.otlib.loaders.ThingDataLoader;
			import nail.otlib.things.ThingCategory;
			import nail.otlib.things.ThingType;
			import nail.otlib.utils.SpriteData;
			import nail.otlib.utils.SpriteUtils;
			import nail.otlib.utils.ThingData;
			import nail.settings.Settings;
			import nail.utils.SaveHelper;
			import nail.utils.StringUtil;
			import nail.utils.WindowUtils;
			import nail.workers.Command;
			
			//--------------------------------------------------------------------------
			//
			// PROPERTIES
			//
			//--------------------------------------------------------------------------
			
			private var _settings : ObjectBuilderSettings = new ObjectBuilderSettings();
			
			[Bindable]
			private var _spritesCollection : ArrayCollection = new ArrayCollection(); 
			
			private var _thingData : ThingData;
			
			private var _nextThingData : ThingData;
			
			private var _thingDataChanged : Boolean;
			
			[Bindable]
			private var _info : AssetsInfo;
			
			private var _selectIndex : int;
			
			private var _spriteMin : uint;
			
			private var _spriteMax :uint;
			
			private var _logText : String = "";
			
			private var _logWindow : LogWindow;
			
			private var _autosave : Boolean;
			
			private var _autosaveChanged : Boolean;
			
			//--------------------------------------------------------------------------
			//
			// METHODS
			//
			//--------------------------------------------------------------------------
			
			//--------------------------------------
			// Public
			//--------------------------------------
			
			public function setAssetsInfo(info:AssetsInfo) : void
			{
				var visible : Boolean;
				
				_info = info;
				
				if (_info != null)
				{
					assetsVersionLabel.text = AssetsVersion.getVersionByValue(_info.version).toString();
					datSignatureLabel.text = _info.datSignature.toString(16).toUpperCase();
					itemsCountLabel.text = _info.maxItemId.toString();
					outfitsCountLabel.text  =_info.maxOutfitId.toString();
					effectsCountLabel.text = _info.maxEffectId.toString();
					missilesCountLabel.text = _info.maxMissileId.toString();
					sprSignatureLabel.text = _info.sprSignature.toString(16).toUpperCase();
					spritesCountLabel.text = _info.maxSpriteId.toString();
					thingStepper.minimum = getMinThingId();
					thingStepper.maximum = getMaxThingId();
					spriteStepper.minimum = _info.minSpriteId;
					spriteStepper.maximum = _info.maxSpriteId;
				}
			}
			
			public function setThing(thing:ThingType, sprites:Vector.<SpriteData>) : void
			{
				if (thing == null) 
				{
					throw new ArgumentError("Parameter thing cannot be null.");
				}
				
				if (sprites == null) 
				{
					throw new ArgumentError("Parameter sprites cannot be null.");
				}
				
				this.thingData = new ThingData(thing, sprites);
			}
			
			public function setSpriteList(target:uint, min:uint, max:uint, sprites:Vector.<SpriteData>) : void
			{
				var length :uint;
				var i : int;
				var sprite : SpriteData;
				
				if (sprites == null) 
				{
					throw new ArgumentError("Parameter sprites cannot be null.");
				}
				
				_spritesCollection.removeAll();
				_selectIndex = -1;
				_spriteMin = min;
				_spriteMax = max;
				
				length = sprites.length;
				for (i = 0; i < length; i++)
				{
					sprite = sprites[i];
					if (sprite == null)
					{
						throw new Error("Invalid sprite.");
					}
					
					_spritesCollection.addItem(sprite);
					
					if (sprite.id == target)
					{
						_selectIndex = _spritesCollection.getItemIndex(sprite);
					}
				}
			}
			
			public function appendLog(text:String) : void
			{
				if (text != null)
				{
					_logText += "&gt;&gt; " + text + "<br/>";
					
					if (_logWindow != null)
					{
						_logWindow.text = _logText;
					}
				}
			}
			
			public function saveThingChanges() : void
			{
				if (this.loaded &&
					this.thingData != null &&
					this.thingAtrributes.changed)
				{
					if (this.thingAtrributes.saveChanges())
					{
						sendCommand(new ChangeThingCommand(thingAtrributes.thingData));
					}
				}
			}
			
			public function clear() : void
			{
				_thingData = null;
				_thingDataChanged = false
				_info = null;
				_nextThingData = null;
				_selectIndex = -1;
				_spriteMax 0;
				_spriteMin 0;
				_spritesCollection.removeAll();
				
				editThing(null);
				thingView.thingData = null;
				assetsVersionLabel.text = null;
				datSignatureLabel.text = null;
				itemsCountLabel.text = null;
				outfitsCountLabel.text = null;
				effectsCountLabel.text = null;
				missilesCountLabel.text = null;
				sprSignatureLabel.text = null;
				spritesCountLabel.text = null;
				categoryDropDownList.selectedIndex = 0;
				thingStepper.value = 0;
				spriteStepper.value = 0;
				_logText = "";
			}
			
			//--------------------------------------
			// Override Public
			//--------------------------------------
			
			override public function getSettings() : Settings
			{
				return _settings;
			}
			
			//--------------------------------------
			// Override Protected
			//--------------------------------------
			
			override protected function commitProperties() : void
			{
				super.commitProperties();
				
				if (_thingDataChanged)
				{
					setThingData(_nextThingData);
					_thingDataChanged = false;
				}
				
				if (_autosaveChanged)
				{
					menuXML[1].menuitem[0].@toggled = _autosave; // Edit > Autosave Changes
					_settings.autosaveThingChanges = _autosave;
					_autosaveChanged = false;
				}
			}
			
			override protected function createMenuDataProvider() : XMLList
			{
				return menuXML;
			}
			
			//--------------------------------------
			// Private
			//--------------------------------------
			
			private function loadAssets(dat:File, spr:File, version:AssetsVersion) : void
			{
				sendCommand(new LoadAssetsCommand(dat, spr, version));
			}
			
			private function compileAssets(dat:File, spr:File, version:AssetsVersion) : void
			{
				if (this.autosave)
				{
					this.saveThingChanges();
				}
				
				sendCommand(new CompileAssetsCommand(dat, spr, version));
			}
			
			private function onCreateNew() : void
			{
				var window : NewAssetsWindow;
				window = new NewAssetsWindow();
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler (event:Event) : void
				{
					if (window.version != null)
					{
						sendCommand(new CreateNewFilesCommand(window.version));
					}
				}
			}
			
			private function onOpenFile() : void
			{
				var window : OpenAssetsWindow;
				window = new OpenAssetsWindow();
				window.directory = _settings.getLastDirectory();
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					_settings.setLastDirectory(window.datFile);
					
					if (window.datFile != null && window.sprFile != null && window.version != null)
					{
						loadAssets(window.datFile, window.sprFile, window.version);
					}
				}
			}
			
			private function onImportThingData(replace:ThingData = null) : void
			{
				var window : ImportThingWindow;
				
				if (!this.loaded)
				{
					return;
				}
				
				window = new ImportThingWindow();
				window.directory = _settings.getLastImportExportDirectory();
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					_settings.setLastImportExportDirectory(window.directory);
					
					if (window.thingData != null)
					{
						sendCommand(new ImportThingCommand(window.thingData, replace));
					}
				}
			}
			
			private function onImportThingDataList(list:Vector.<ThingData>) : void
			{
				var length : uint;
				var i : uint;
				var data : ThingData;
				var message : String;
				
				if (!this.loaded)
				{
					return;
				}
				
				length = list.length;
				if (length == 1)
				{
					data = list[0];
					if (data.category == thingData.category)
					{
						message = StringUtil.substitute("Want to replace {0} id {1}?", data.category, data.id);
						Alert.show(message, "Import Object", Alert.YES | Alert.NO | Alert.CANCEL, this, closeHandler);
					}
					else 
					{
						sendCommand(new ImportThingCommand(data));
					}
				}
				else 
				{
					for (i = 0; i < length; i++)
					{
						data = list[i];
						sendCommand(new ImportThingCommand(data));
					}
				}
				
				function closeHandler(event:CloseEvent) : void
				{
					if (event.detail == Alert.YES)
					{
						sendCommand(new ImportThingCommand(data, thingData));
					}
					else if (event.detail == Alert.NO)
					{
						sendCommand(new ImportThingCommand(data));
					}
				}
			}
			
			private function onExportThingData(fileName:String, format:String, directory:File, version:AssetsVersion, data:ThingData) : void
			{
				var bytes : ByteArray;
				var bitmap : BitmapData;
				var helper : SaveHelper;
				
				try
				{
					if (ImageFormat.hasImageFormat(format))
					{
						bitmap = ThingData.getSpriteSheet(data);
						bytes = ImageCodec.encode(bitmap, format);
						
					}
					else if (format == "obd")
					{
						bytes = ThingData.serialize(data, version);
					}
					
					helper = new SaveHelper();
					helper.addFile(bytes, fileName, format, directory);
					helper.save();
				} 
				catch(error:Error)
				{
					NailMain.instance.onError(error.message, error.getStackTrace(), error.errorID);
				}
			}
			
			private function onImportSprites(list:Vector.<BitmapData>) : void
			{
				var bitmap : BitmapData;
				var length : uint;
				var i :uint;
				var spritePixelsList : Vector.<ByteArray>;
				
				if (list == null || list.length == 0)
				{
					return;
				}
				
				length = list.length;
				if (length == 1)
				{
					bitmap = list[0];
					if (bitmap.width < 32 || bitmap.height < 32)
					{
						Alert.show("Invalid sprite size. The minimum size of a sprite must be 32x32 pixels.", "Import Sprite");
						return;
					}
					else if (bitmap.width == 32 && bitmap.height == 32)
					{
						bitmap = SpriteUtils.removeMagenta(bitmap);
						
						spritePixelsList = new Vector.<ByteArray>(length, true);
						spritePixelsList[0] = bitmap.getPixels(bitmap.rect);
						sendCommand(new ImportSpriteCommand(spritePixelsList));
					}
					else 
					{
						this.cropBitmap(bitmap);
					}
				}
				else
				{
					spritePixelsList = new Vector.<ByteArray>(length, true);
					
					for (i = 0; i < length; i++)
					{
						bitmap = list[i];
						if (bitmap.width != 32 || bitmap.height != 32)
						{
							Alert.show("Invalid sprite size. The minimum size of a sprite must be 32x32 pixels.", "Import Sprite");
							return;
						}
						
						bitmap = SpriteUtils.removeMagenta(bitmap);
						spritePixelsList[i] = bitmap.getPixels(bitmap.rect);
					}
					
					sendCommand(new ImportSpriteCommand(spritePixelsList));
				}
			}
			
			private function onExportSprites(fileName:String, format:String, directory:File, sprites:Vector.<SpriteData>) : void
			{
				var helper : SaveHelper;
				var length : uint;
				var i : uint;
				var spriteData : SpriteData;
				var bitmap : BitmapData;
				var bytes : ByteArray;
				var name : String;
				
				try
				{
					if (ImageFormat.hasImageFormat(format))
					{
						helper = new SaveHelper();
						
						length = sprites.length;
						for (i = 0; i < length; i++)
						{
							spriteData = sprites[i];
							bitmap = spriteData.getBitmap(0xFFFF00FF);
							if (!SpriteUtils.isEmpty(bitmap))
							{
								bytes = ImageCodec.encode(bitmap, format);
								name = fileName + "_" + spriteData.id;
								helper.addFile(bytes, name, format, directory);
							}
						}
						
						helper.save();
					}
				} 
				catch(error:Error)
				{
					NailMain.instance.onError(error.message, error.getStackTrace(), error.errorID);
				}
			}
			
			private function cropBitmap(bitmap:BitmapData) : void
			{
				var window : CropImageWindow;
				var bounds : Rectangle;
				
				window = new CropImageWindow();
				window.bitmap = bitmap;
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				// Centralize window.
				bounds = Screen.mainScreen.bounds;
				window.nativeWindow.x = (bounds.width - window.nativeWindow.width) * 0.5;
				window.nativeWindow.y = (bounds.height - window.nativeWindow.height) * 0.5;
				
				function windowCloseHandler(event:Event) : void
				{
					if (window.bitmapList != null)
					{
						onImportSprites(window.bitmapList);
					}
				}
			}
			
			private function selectSprite(id:uint) : void
			{
				var length :uint;
				var i : uint;
				var sprite : SpriteData;
				
				// Return if id is current selected.
				if (!this.loaded || this.spritesList.selectedSpriteId == id)
				{
					return;
				}
				
				// Search index if id is in range of loaded list.
				if (id >= _spriteMin && id <= _spriteMax)
				{
					length = _spritesCollection.length;
					for (i = 0; i < length; i++)
					{
						sprite = _spritesCollection.getItemAt(i) as SpriteData;
						if (sprite.id == id)
						{
							spritesList.selectedIndex = i;
							spritesList.ensureIndexIsVisible(i);
							spriteStepper.value = id;
							break;
						}
					}
				}
				else 
				{
					// Request new list by target id.
					sendCommand(new GetSpriteListCommand(id));
				}
			}
			
			private function onCompile() : void
			{
				var window : CompileAssetsWindow;
				
				if (!this.loaded)
				{
					return;
				}
				
				window = new CompileAssetsWindow();
				window.directory = _settings.getLastDirectory();
				window.version = AssetsVersion.getVersionByValue(_info.version);
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					_settings.setLastDirectory(window.directory);
					
					if (window.datFile != null && window.sprFile != null && window.version != null)
					{
						compileAssets(window.datFile, window.sprFile, window.version);
					}
				}
			}
			
			private function onCopySprite() : void
			{
				var data : SpriteData;
				var bitmap : BitmapData;
				
				if (!loaded)
				{
					return;
				}
				
				data = spritesList.selectedSprite;
				if (data != null)
				{
					bitmap = data.getBitmap(0xFFFF00FF);
					Clipboard.generalClipboard.clear();
					Clipboard.generalClipboard.setData(ClipboardFormats.BITMAP_FORMAT, bitmap);
				}
			}
			
			private function onPasteSprite() : void
			{
				var bitmap : BitmapData;
				var data : SpriteData;
				
				if (!loaded)
				{
					return;
				}
				
				if (Clipboard.generalClipboard.hasFormat(ClipboardFormats.BITMAP_FORMAT))
				{
					bitmap = BitmapData(Clipboard.generalClipboard.getData(ClipboardFormats.BITMAP_FORMAT));
					bitmap = SpriteUtils.removeMagenta(bitmap);
					
					data = spritesList.selectedSprite;
					if (data != null)
					{
						sendCommand(new ReplaceSpriteCommand(data.id, bitmap));
					}
				}
			}
			
			private function openLogWindow() : void
			{
				if (_logWindow == null)
				{
					_logWindow = new LogWindow();
					_logWindow.text = _logText;
					_logWindow.addEventListener(Event.CLOSE, logWindowCloseHandler);
					_logWindow.open();
					
					WindowUtils.centralizeWindowOnScreen(_logWindow);
				}
				else 
				{
					_logWindow.activate();
				}
			}
			
			private function closeLogWindow() : void
			{
				if (_logWindow!= null && !_logWindow.closed)
				{
					_logWindow.close();
				}
			}
			
			private function editThing(data:ThingData) : void
			{
				var visible : Boolean;
				
				thingAtrributes.thingData = data;
				thingAtrributes.visible = (data != null)
				confirmButton.enabled = thingAtrributes.changed;
				cancelButton.enabled = (data != null);
				
				if (this.loaded && data != null)
				{
					// Hide unused controls to non-item objects.
					visible = (data.category == ThingCategory.ITEM);
					
					thingAtrributes.groundGroupCheckBox.visible = visible;
					thingAtrributes.groundGroupCheckBox.includeInLayout = visible;
					thingAtrributes.automapGroupCheckBox.visible = visible;
					thingAtrributes.automapGroupCheckBox.includeInLayout = visible;
					thingAtrributes.hasElevationGroupCheckBox.visible = visible;
					thingAtrributes.hasElevationGroupCheckBox.includeInLayout = visible;
					thingAtrributes.equipGroupCheckBox.visible = visible;
					thingAtrributes.equipGroupCheckBox.includeInLayout = visible;
					thingAtrributes.writeReadGroupCheckBox.visible = visible;
					thingAtrributes.writeReadGroupCheckBox.includeInLayout = visible;
					thingAtrributes.flagsLeftColumn.visible = visible;
					thingAtrributes.flagsLeftColumn.includeInLayout = visible;
					thingAtrributes.pickupableCheckBox.visible = visible;
					thingAtrributes.pickupableCheckBox.includeInLayout = visible;
					thingAtrributes.pickupableCheckBox.visible = visible;
					thingAtrributes.pickupableCheckBox.includeInLayout = visible;
					thingAtrributes.hangableCheckBox.visible = visible;
					thingAtrributes.hangableCheckBox.includeInLayout = visible;
					thingAtrributes.horizontalCheckBox.visible = visible;
					thingAtrributes.horizontalCheckBox.includeInLayout = visible;
					thingAtrributes.verticalCheckBox.visible = visible;
					thingAtrributes.verticalCheckBox.includeInLayout = visible;
					thingAtrributes.rotatableCheckBox.visible = visible;
					thingAtrributes.rotatableCheckBox.includeInLayout = visible;
					thingAtrributes.dontHideCheckBox.visible = visible;
					thingAtrributes.dontHideCheckBox.includeInLayout = visible;
					thingAtrributes.translucentCheckBox.visible = visible;
					thingAtrributes.translucentCheckBox.includeInLayout = visible;
					thingAtrributes.isLyingObjectCheckBox.visible = visible;
					thingAtrributes.isLyingObjectCheckBox.includeInLayout = visible;
					thingAtrributes.fullGroundCheckBox.visible = visible;
					thingAtrributes.fullGroundCheckBox.includeInLayout = visible;
					thingAtrributes.ignoreLookCheckBox.visible = visible;
					thingAtrributes.ignoreLookCheckBox.includeInLayout = visible;
					
					// Hide 'Market' GroupCheckBox.
					visible = (_info.version >= 940 && data.category == ThingCategory.ITEM);
					thingAtrributes.marketGroupCheckBox.visible = visible;
					thingAtrributes.marketGroupCheckBox.includeInLayout = visible;
					
					// Hide 'No Move Animation' CheckBox by version.
					visible = (_info.version >= 1010 && data.category == ThingCategory.ITEM);
					thingAtrributes.noMoveAnimationCheckBox.visible = visible;
					thingAtrributes.noMoveAnimationCheckBox.includeInLayout = visible;
					
					// Hide 'Action' GroupCheckBox and 'Usable' CheckBox by version.
					visible = (_info.version >= 1021 && data.category == ThingCategory.ITEM);
					thingAtrributes.actionGroupCheckBox.visible = visible;
					thingAtrributes.actionGroupCheckBox.includeInLayout = visible;
					thingAtrributes.usableCheckBox.visible = visible;
					thingAtrributes.usableCheckBox.includeInLayout = visible;
				}
			}
			
			private function getCurrentCategory() : String
			{
				switch(categoryDropDownList.selectedIndex)
				{
					case 0:
						return ThingCategory.ITEM;
					case 1:
						return ThingCategory.OUTFIT;
					case 2:
						return ThingCategory.EFFECT;
					case 3:
						return ThingCategory.MISSILE;
				}
				return null;
			}
			
			private function getMinThingId() : uint
			{
				var category : String = getCurrentCategory();
				if (this.loaded && !StringUtil.isEmptyOrNull(category))
				{
					switch(category)
					{
						case ThingCategory.ITEM:
							return _info.minItemId;
						case ThingCategory.OUTFIT:
							return _info.minOutfitId;
						case ThingCategory.EFFECT:
							return _info.minEffectId;
						case ThingCategory.MISSILE:
							return _info.minMissileId;
					}
				}
				return 0;
			}
			
			private function getMaxThingId() : uint
			{
				var category : String = getCurrentCategory();
				if (this.loaded && !StringUtil.isEmptyOrNull(category))
				{
					switch(category) 
					{
						case ThingCategory.ITEM:
							return _info.maxItemId;
						case ThingCategory.OUTFIT:
							return _info.maxOutfitId;
						case ThingCategory.EFFECT:
							return _info.maxEffectId;
						case ThingCategory.MISSILE:
							return _info.maxMissileId;
					}
				}
				return 0;
			}
			
			private function setThingData(data:ThingData) : void
			{
				_thingData = data;
				thingView.thingData = data;
				
				if (data != null)
				{
					thingStepper.value = data.id;
					
					switch(data.category)
					{
						case ThingCategory.ITEM:
							categoryDropDownList.selectedIndex = 0; 
							break;
							
						case ThingCategory.OUTFIT:
							categoryDropDownList.selectedIndex = 1; 
							break;
						case ThingCategory.EFFECT:
							categoryDropDownList.selectedIndex = 2; 
							break;
						
						case ThingCategory.MISSILE:
							categoryDropDownList.selectedIndex = 3; 
							break;
					}
				}
			}
			
			private function sendCommand(command:Command) : void
			{
				NailMain.instance.sendCommand(command);
			}
			
			//--------------------------------------
			// Event Handlers
			//--------------------------------------
			
			protected function confirmButtonClickHandler(event:MouseEvent) : void
			{
				if (thingAtrributes.changed)
				{
					if (thingAtrributes.saveChanges())
					{
						sendCommand(new ChangeThingCommand(thingAtrributes.thingData));
					}
				}
			}
			
			protected function cancelButtonClickHandler(event:MouseEvent) : void
			{
				editThing(null);
			}
			
			protected function listUpdateCompleteHandler(event:FlexEvent) : void
			{
				if (_selectIndex != -1)
				{
					spritesList.selectedIndex = _selectIndex;
					spritesList.ensureIndexIsVisible(_selectIndex);
					spriteStepper.value = this.spritesList.selectedSpriteId;
				}
				_selectIndex = -1;
			}
			
			override protected function creationCompleteHandler(event:FlexEvent) : void
			{
				super.creationCompleteHandler(event);
				
				this.autosave = _settings.autosaveThingChanges;
			}
			
			override protected function menuItemClickHandler(event:MenuEvent) : void
			{
				var data : String = String(event.item.@data);
				
				switch(data) 
				{
					case "fileNew":
						this.onCreateNew();
						break;
					
					case "fileOpen":
						this.onOpenFile();
						break;
					
					case "fileCompile":
						this.onCompile();
						break;
					
					case "editAutosave":
						this.autosave = !this.autosave;
						break;
					
					case "windowOpenLog":
						this.openLogWindow();
						break;
					
					case "helpAbout":
						this.onAboutApplication();
						break;
				}
			}
			
			protected function categoryDropDownListChangeHandler(event:IndexChangeEvent) : void
			{
				if (this.loaded)
				{
					thingStepper.minimum = getMinThingId();
					thingStepper.maximum = getMaxThingId();
					thingStepper.value = thingStepper.minimum;
					sendCommand(new GetThingCommand(thingStepper.minimum, getCurrentCategory()));
				}
			}
			
			protected function thingChangedHandler(event:ThingEditorEvent) : void
			{
				var title : String = "";
				if (event.data != null)
				{
					title = event.data.category + " " + event.data.id;
				}
				
				this.updateTitle(title);
				
				confirmButton.enabled = false;
			}
			
			protected function thingPropertyChangedHandler(event:ThingEditorEvent) : void
			{
				var title : String = "";
				var message : String;
				
				if (event.data != null)
				{
					title = event.data.category + " " + event.data.id;
				}
				
				this.updateTitle(title, !thingAtrributes.changed);
				
				confirmButton.enabled = thingAtrributes.changed;
				
				if (event.property != null)
				{
					message = "{0} id <b>{1}</b> property <b>{2}</b> changed from <b>{3}</b> to <b>{4}</b>.";
					this.appendLog(StringUtil.substitute(message,
						StringUtil.capitaliseFirstLetter(event.data.category),
						event.data.id,
						event.property,
						event.oldValue,
						event.newValue));
				}
			}
			
			protected function thingSpriteDoubleClickHandler(event:ThingEditorEvent) : void
			{
				selectSprite(event.sprite);
			}
			
			protected function thingStepperChangeHandler(event:Event) : void
			{
				if (this.loaded && this.thingData != null)
				{
					sendCommand(new GetThingCommand(thingStepper.value, getCurrentCategory()));
				}
			}
			
			protected function replaceThingButtonClickHandler(event:MouseEvent) : void
			{
				this.onImportThingData(this.thingData);
			}
			
			protected function importThingButtonClickHandler(event:MouseEvent) : void
			{
				this.onImportThingData();
			}
			
			protected function exportThingButtonClickHandler(event:MouseEvent) : void
			{
				var window : ExportWindow;
				
				if (!this.loaded || this.thingData == null)
				{
					return;
				}
				
				window = new ExportWindow();
				window.enableObdFormat = true;
				window.fileName = thingData.category + "_" + thingData.id;
				window.directory = _settings.getLastImportExportDirectory();
				window.format = _settings.getLastExportThingFormat();
				window.version = _settings.getLastExportThingVersion() || AssetsVersion.getVersionByValue(_info.version);
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					if (window.fileName != null &&
						window.directory != null &&
						window.format != null)
					{
						_settings.setLastImportExportDirectory(window.directory);
						_settings.setLastExportThingFormat(window.format);
						_settings.setLastExportThingVersion(window.version);
						
						onExportThingData(window.fileName, window.format, window.directory, window.version, thingData);
					}
				}
			}
			
			protected function duplicateThingButtonClickHandler(event:MouseEvent):void
			{
				if (this.loaded && this.thingData != null)
				{
					sendCommand(new DuplicateThingCommand(this.thingData));
				}
			}
			
			protected function editThingButtonClickHandler(event:MouseEvent) : void
			{
				var message : String;
				
				if (!this.loaded || thingAtrributes.thingData == this.thingData)
				{
					return;
				}
				
				if (this.autosave)
				{
					this.saveThingChanges();
				}
				
				if (thingAtrributes.thingData != null && thingAtrributes.changed)
				{
					message = StringUtil.substitute("Save changes in the {0} {1}?",
						thingAtrributes.thingData.category,
						thingAtrributes.thingData.id);
					Alert.show(message, "Info", Alert.YES | Alert.NO | Alert.CANCEL, this, closeHandler);
					return;
				}
				
				editThing(thingData);
				
				function closeHandler(event:CloseEvent) : void
				{
					if (event.detail == Alert.YES)
					{
						saveThingChanges();
					}
					else if (event.detail == Alert.NO)
					{
						appendLog(StringUtil.substitute("Unsaved changes to {0} id <b>{1}</b>.",
							thingAtrributes.thingData.category,
							thingAtrributes.thingData.id));
					}
					else if (event.detail == Alert.CANCEL)
					{
						return
					}
					
					editThing(thingData);
				}
			}
			
			protected function newThingButtonClickHandler(event:MouseEvent) : void
			{
				var category : String;
				
				if (this.loaded)
				{
					category = getCurrentCategory();
					if (category != null)
					{
						sendCommand(new NewThingCommand(category));
					}
				}
			}
			
			protected function removeThingButtonClickHandler(event:MouseEvent) : void
			{
				var message : String;
				
				if (this.loaded && thingData != null)
				{
					message = StringUtil.substitute("Are you sure want to remove the {0} id {1}?",
						thingData.category, thingData.id);
					Alert.show(message, "Remove", Alert.YES |  Alert.NO, this, alertCloseHandler);
				}
				
				function alertCloseHandler(event:CloseEvent) : void
				{
					if (event.detail == Alert.YES)
					{
						sendCommand(new RemoveThingCommand(thingData));
					}
				}
			}
			
			protected function thingViewGroupNativeDragEnterHandler(event:NativeDragEvent) : void
			{
				if (loaded && event.target === thingViewGroup)
				{
					if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
					{
						NativeDragManager.dropAction = NativeDragActions.LINK;
						DragManager.acceptDragDrop(thingViewGroup);
					}
				}
			}
			
			protected function thingViewGroupNativeDragDropHandler(event:NativeDragEvent) : void
			{
				var clipboard : Clipboard;
				var dropfiles : Array;
				var length : uint;
				var i : uint;
				var files : Array;
				var loader : ThingDataLoader;
				
				if (!loaded)
				{
					return;
				}
				
				clipboard = event.clipboard;
				
				if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					dropfiles = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					length = dropfiles.length;
					files = [];
					
					for (i = 0; i < length; i++)
					{
						files.push(dropfiles[i]);
					}
				}
				
				loader = new ThingDataLoader();
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.loadFiles(files);
				
				function completeHandler(event:Event) : void
				{
					onImportThingDataList(loader.thingDataList);
				}
			}
			
			protected function replaceSpriteHandler(event:Event) : void
			{
				var loader : BitmapLoader;
				
				if (!this.loaded || this.spritesList.selectedSpriteId == 0)
				{
					return;
				}
				
				loader = new BitmapLoader(_settings.getLastImportExportDirectory());
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.browseForOpen("Select Image");
				
				function completeHandler(event:Event) : void
				{
					var bitmap : BitmapData;
					var spriteData : SpriteData;
					
					bitmap = loader.bitmap;
					if (bitmap.width != 32 && bitmap.height != 32)
					{
						Alert.show("Invalid size. Please, import bitmap with 32x32 pixels.", "Replace Sprite");
						return;
					}
					
					_settings.setLastImportExportDirectory(loader.directory);
					
					bitmap = SpriteUtils.removeMagenta(bitmap);
					
					spriteData = spritesList.selectedSprite;
					if (spriteData != null)
					{
						sendCommand(new ReplaceSpriteCommand(spriteData.id, bitmap));
					}
				}
			}
			
			protected function importSpriteButtonClickHandler(event:MouseEvent) : void
			{
				var loader : BitmapLoader;
				
				if (!this.loaded)
				{
					return;
				}
				
				loader = new BitmapLoader(_settings.getLastImportExportDirectory())
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.browseForOpenMultiple("Select Images");
				
				function completeHandler(event:Event) : void
				{
					_settings.setLastImportExportDirectory(loader.directory);
					
					onImportSprites(loader.bitmapList);
				}
			}
			
			protected function exportSpriteHandler(event:Event) : void
			{
				var window : ExportWindow;
				
				if (!this.loaded || spritesList.selectedSprites.length == 0)
				{
					return;
				}
				
				window = new ExportWindow();
				window.fileName = "sprite";
				window.format = _settings.getLastExportSpriteFormat();
				window.directory = _settings.getLastImportExportDirectory();
				window.enableObdFormat = false;
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					if (window.fileName != null &&
						window.format != null &&
						window.directory != null)
					{
						_settings.setLastImportExportDirectory(window.directory);
						_settings.setLastExportSpriteFormat(window.format);
						
						onExportSprites(window.fileName, window.format, window.directory, spritesList.selectedSprites);
					}
				}
			}
			
			protected function newSpriteButtonClickHandler(event:MouseEvent) : void
			{
				if (this.loaded)
				{
					sendCommand(new Command(CommandType.NEW_SPRITE));
				}
			}
			
			protected function removeSpriteHandler(event:Event) : void
			{
				var sprites : Vector.<SpriteData>;
				var list : Vector.<uint>;
				var length : uint;
				var i : uint;
				
				if (!this.loaded)
				{
					return;
				}
				
				sprites = spritesList.selectedSprites;
				length = sprites.length;
				if (length > 0)
				{
					list = new Vector.<uint>(length, true);
					
					for (i = 0; i < length; i++)
					{
						list[i] = sprites[i].id;
					}
					
					list.sort(Array.NUMERIC | Array.DESCENDING);
					sendCommand(new RemoveSpritesCommand(list));
				}
			}
			
			protected function spritesListChangeHandler(event:IndexChangeEvent) : void
			{
				if (!this.loaded)
				{
					return;
				}
				
				spriteStepper.value = this.spritesList.selectedSpriteId;
				replaceSpriteButton.enabled = (spritesList.selectedSprites.length == 1);
			}
			
			protected function spriteStepperChangeHandler(event:Event) : void
			{
				if (this.loaded)
				{
					selectSprite(spriteStepper.value);
				}
			}
			
			protected function spritesListNativeDragEnterHandler(event:NativeDragEvent) : void
			{
				if (loaded && event.target === spritesList)
				{
					if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
					{
						NativeDragManager.dropAction = NativeDragActions.LINK;
						DragManager.acceptDragDrop(spritesList);
					}
				}
			}
			
			protected function spritesListNativeDragDropHandler(event:NativeDragEvent) : void
			{
				var clipboard : Clipboard;
				var dropfiles : Array;
				var length : uint;
				var i : uint;
				var files : Array;
				var loader : BitmapLoader;
				
				if (!loaded)
				{
					return;
				}
				
				clipboard = event.clipboard;
				
				if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					dropfiles = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					length = dropfiles.length;
					files = [];
					
					for (i = 0; i < length; i++)
					{
						files.push(dropfiles[i]);
					}
				}
				
				loader = new BitmapLoader();
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.loadFiles(files);
				
				function completeHandler(event:Event) : void
				{
					onImportSprites(loader.bitmapList);
				}
			}
			
			protected function logWindowCloseHandler(event:Event) : void
			{
				_logWindow.removeEventListener(Event.CLOSE, logWindowCloseHandler);
				_logWindow = null;
			}
			
			protected function applicationClosingHandler(event:Event) : void
			{
				this.closeLogWindow();
			}
			
			//--------------------------------------
			// Getters / Setters 
			//--------------------------------------
			
			public function get loaded() : Boolean
			{
				return (_info != null);
			}
			
			public function get thingData() : ThingData
			{
				return _thingData;
			}
			
			public function set thingData(value:ThingData) : void
			{
				if (_thingData != value)
				{
					_nextThingData = value;
					_thingDataChanged = true;
					invalidateProperties();
				}
			}
			
			public function get autosave() : Boolean
			{
				return _autosave;
			}
			
			public function set autosave(value:Boolean) : void
			{
				if (_autosave != value)
				{
					_autosave = value;
					_autosaveChanged = true;
					invalidateProperties();
				}
			}
			
		]]>
	</fx:Script>
	
	<nail:toolBar>
		<s:HGroup width="100%"
				  height="100%"
				  verticalAlign="middle"
				  paddingLeft="10"
				  paddingRight="10">
			<s:Button width="25"
					  height="25"
					  toolTip="New"
					  icon="{Icons.NEW_FILES_WHITE}"
					  click="onCreateNew()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<s:Button width="25"
					  height="25"
					  toolTip="Open"
					  icon="{Icons.OPEN_WHITE}"
					  click="onOpenFile()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<s:Button width="25"
					  height="25"
					  toolTip="Compile"
					  icon="{Icons.SAVE_WHITE}"
					  click="onCompile()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<nail:ShadowLine height="20"/>
			<s:Button width="25"
					  height="25"
					  toolTip="Log Window"
					  icon="{Icons.LOG_WHITE}"
					  click="openLogWindow()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
		</s:HGroup>
	</nail:toolBar>
	
	<s:BorderContainer width="165"
					   height="100%"
					   fontSize="11"
					   skinClass="nail.components.skins.BorderContainerSkin">
		<s:layout>
			<s:VerticalLayout horizontalAlign="center"
							  paddingRight="5"
							  paddingLeft="5"
							  paddingTop="10"
							  paddingBottom="10"
							  gap="10"/>
		</s:layout>
		
		<nail:GroupBox label="Info"
					   width="100%"
					   fontSize="10">
			<nail:layout>
				<s:TileLayout requestedColumnCount="2"
							  paddingLeft="5"
							  paddingRight="5"
							  paddingTop="10"
							  paddingBottom="10"/>
			</nail:layout>
			<s:Label text="Version:"/>
			<s:Label id="assetsVersionLabel"/>
			<s:Label text="Dat:"/>
			<s:RichEditableText id="datSignatureLabel"
								editable="false"
								height="15"/>
			<s:Label text="Items:"/>
			<s:RichEditableText id="itemsCountLabel"
								editable="false"
								height="15"/>
			<s:Label text="Outfits:"/>
			<s:RichEditableText id="outfitsCountLabel"
								editable="false"
								height="15"/>
			<s:Label text="Effects:"/>
			<s:RichEditableText id="effectsCountLabel"
								editable="false"
								height="15"/>
			<s:Label text="Missiles:"/>
			<s:RichEditableText id="missilesCountLabel"
								editable="false"
								height="15"/>
			<s:Label text="Spr:"/>
			<s:RichEditableText id="sprSignatureLabel"
								editable="false"
								height="15"/>
			<s:Label text="Sprites:"/>
			<s:RichEditableText id="spritesCountLabel"
								editable="false"
								height="15"/>
		</nail:GroupBox>
		
		<s:Line width="100%">
			<s:stroke>
				<s:SolidColorStroke color="0x272727"/>
			</s:stroke>
			<s:filters>
				<s:DropShadowFilter color="0x636363"
									blurX="1"
									blurY="1"
									distance="1"/>
			</s:filters>
		</s:Line>
		
		<s:DropDownList id="categoryDropDownList"
						selectedIndex="0"
						width="100%"
						height="20"
						change="categoryDropDownListChangeHandler(event)">
			<s:dataProvider>
				<s:ArrayList>
					<fx:String>Item</fx:String>
					<fx:String>Outfit</fx:String>
					<fx:String>Effect</fx:String>
					<fx:String>Missile</fx:String>
				</s:ArrayList>
			</s:dataProvider>
		</s:DropDownList>	
		
		<nail:GroupBox id="thingViewGroup"
					   label="View"
					   width="100%"
					   height="100%"
					   nativeDragEnter="thingViewGroupNativeDragEnterHandler(event)"
					   nativeDragDrop="thingViewGroupNativeDragDropHandler(event)">
			<controls:ThingView id="thingView"
								horizontalCenter="0"
								verticalCenter="0"/>
		</nail:GroupBox>
		
		<nail:XNumericStepper id="thingStepper"
							  width="100%"
							  fontSize="11"
							  change="thingStepperChangeHandler(event)"/>
		
		<s:HGroup width="100%"
				  horizontalAlign="right"
				  verticalAlign="middle"
				  gap="3">
			<s:Button id="replaceThingButton"
					  toolTip="Replace"
					  width="19"
					  height="19"
					  icon="{Icons.REPLACE}"
					  click="replaceThingButtonClickHandler(event)"/>
			<s:Button id="importThingButton"
					  toolTip="Import"
					  width="19"
					  height="19"
					  icon="{Icons.IMPORT}"
					  click="importThingButtonClickHandler(event)"/>
			<s:Button id="exportThingButton"
					  toolTip="Export"
					  width="19"
					  height="19"
					  icon="{Icons.EXPORT}"
					  click="exportThingButtonClickHandler(event)"/>
			<s:Button id="editThingButton"
					  toolTip="Edit"
					  width="19"
					  height="19"
					  icon="{Icons.EDIT}"
					  click="editThingButtonClickHandler(event)"/>
			<s:Button id="duplicateThingButton"
					  toolTip="Duplicate"
					  width="19"
					  height="19"
					  icon="{Icons.DUPLICATE}"
					  click="duplicateThingButtonClickHandler(event)"/>
			<s:Button id="newThingButton"
					  toolTip="New"
					  width="19"
					  height="19"
					  icon="{Icons.NEW}"
					  click="newThingButtonClickHandler(event)"/>
			<s:Button id="removeThingButton"
					  toolTip="Remove"
					  width="19"
					  height="19"
					  icon="{Icons.DELETE}"
					  click="removeThingButtonClickHandler(event)"/>
		</s:HGroup>
		
	</s:BorderContainer>
	
	<s:Group width="100%"
			 height="100%">
		<s:layout>
			<s:VerticalLayout gap="-1"/>
		</s:layout>
		
		<s:BorderContainer width="100%"
						   height="100%"
						   skinClass="nail.components.skins.BorderContainerSkin">
			<otlib:ThingTypeEditor id="thingAtrributes"
								   width="100%"
								   height="100%"
								   visible="false"
								   thingChange="thingChangedHandler(event)"
								   thingPropertyChange="thingPropertyChangedHandler(event)"
								   spriteDoubleClick="thingSpriteDoubleClickHandler(event)"/>
		</s:BorderContainer>
		
		<s:BorderContainer width="100%"
						   backgroundColor="0x535353"
						   borderColor="0x272727">
			<s:layout>
				<s:HorizontalLayout horizontalAlign="right"
									verticalAlign="middle"
									paddingLeft="10"
									paddingRight="10"
									paddingTop="3"
									paddingBottom="3"/>
			</s:layout>
			<s:Button id="confirmButton"
					  label="Save"
					  fontSize="11"
					  height="20"
					  enabled="false"
					  click="confirmButtonClickHandler(event)"/>
			<s:Button id="cancelButton"
					  label="Close" 
					  fontSize="11"
					  height="20"
					  enabled="false"
					  click="cancelButtonClickHandler(event)"/>
		</s:BorderContainer>
	</s:Group>
	
	<s:BorderContainer width="165"
					   height="100%"
					   skinClass="nail.components.skins.BorderContainerSkin">
		<s:layout>
			<s:VerticalLayout horizontalAlign="center"
							  paddingRight="5"
							  paddingLeft="5"
							  paddingTop="10"
							  paddingBottom="10"
							  gap="10"/>
		</s:layout>	
		
		<nail:GroupBox label="Sprites"
					   width="100%"
					   height="100%">
			<nail:layout>
				<s:VerticalLayout paddingRight="0"
								  paddingLeft="0"
								  paddingTop="10"
								  paddingBottom="0"/>
			</nail:layout>
			<otlib:SpriteList id="spritesList" 
							  width="100%"
							  height="100%"
							  dataProvider="{_spritesCollection}"
							  allowMultipleSelection="true"
							  dragEnabled="true"
							  fontSize="11"
							  borderAlpha="0"
							  change="spritesListChangeHandler(event)"
							  updateComplete="listUpdateCompleteHandler(event)"
							  copy="onCopySprite()"
							  paste="onPasteSprite()"
							  replace="replaceSpriteHandler(event)"
							  export="exportSpriteHandler(event)"
							  remove="removeSpriteHandler(event)"
							  nativeDragEnter="spritesListNativeDragEnterHandler(event)"
							  nativeDragDrop="spritesListNativeDragDropHandler(event)"/>
		</nail:GroupBox>
			
		<nail:XNumericStepper id="spriteStepper"
							  width="100%"
							  fontSize="11"
							  change="spriteStepperChangeHandler(event)"/>
		
		<s:HGroup width="100%"
				  horizontalAlign="right"
				  verticalAlign="middle"
				  gap="3">
			<s:Button id="replaceSpriteButton"
					  toolTip="Replace"
					  width="19"
					  height="19"
					  icon="{Icons.REPLACE}"
					  click="replaceSpriteHandler(event)"/>
			<s:Button id="importSpriteButton"
					  toolTip="Import"
					  width="19"
					  height="19"
					  icon="{Icons.IMPORT}"
					  click="importSpriteButtonClickHandler(event)"/>
			<s:Button id="exportSpriteButton"
					  toolTip="Export"
					  width="19"
					  height="19"
					  icon="{Icons.EXPORT}"
					  click="exportSpriteHandler(event)"/>
			<s:Button id="copySpriteButton"
					  toolTip="Copy"
					  width="19"
					  height="19"
					  icon="{Icons.COPY}"
					  click="onCopySprite()"/>
			<s:Button id="pasteSpriteButton"
					  toolTip="Paste"
					  width="19"
					  height="19"
					  icon="{Icons.PASTE}"
					  click="onPasteSprite()"/>
			<s:Button id="newSpriteButton"
					  toolTip="New"
					  width="19"
					  height="19"
					  icon="{Icons.NEW}"
					  click="newSpriteButtonClickHandler(event)"/>
			<s:Button id="removeSpriteButton"
					  toolTip="Remove"
					  width="19"
					  height="19"
					  icon="{Icons.DELETE}"
					  click="removeSpriteHandler(event)"/>
		</s:HGroup>	
		
	</s:BorderContainer>
</nail:NailApplication>
