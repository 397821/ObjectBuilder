<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////////////
// 
//  Copyright (c) 2014 <nailsonnego@gmail.com>
// 
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////////
-->

<nail:NailApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					  xmlns:s="library://ns.adobe.com/flex/spark" 
					  xmlns:mx="library://ns.adobe.com/flex/mx"
					  xmlns:nail="library://ns.nail.com/naillib"
					  xmlns:otlib="library://ns.nail.com/otlib"
					  minWidth="800"
					  minHeight="600"
					  backgroundColor="0x494949"
					  showStatusBar="false"
					  displayStateChange="applicationDisplayStateChangeHandler(event)"
					  closing="applicationClosingHandler(event)">
	
	<fx:Declarations>
		<fx:XMLList id="menuXML">
			<menuitem label="{resourceManager.getString('obstrings', 'menu.file')}">
				<menuitem label="{resourceManager.getString('obstrings', 'menu.new')}" data="fileNew" icon="nail.objectbuilder.core.Icons_NEW_FILES"/>
				<menuitem label="{resourceManager.getString('obstrings', 'menu.open')}" data="fileOpen" icon="nail.objectbuilder.core.Icons_OPEN"/>
				<menuitem label="{resourceManager.getString('obstrings', 'menu.compile')}" data="fileCompile" icon="nail.objectbuilder.core.Icons_SAVE"/>
				<menuitem type="separator"/>
				<menuitem label="{resourceManager.getString('obstrings', 'menu.preferences')}" data="filePreferences"/>
				<menuitem label="{resourceManager.getString('obstrings', 'menu.exit')}" data="fileExit"/>
			</menuitem>
			<menuitem label="{resourceManager.getString('obstrings', 'menu.edit')}">
				<menuitem label="{resourceManager.getString('obstrings', 'menu.autoSave')}" type="check" data="editAutosave"/>
			</menuitem>
			<menuitem label="{resourceManager.getString('obstrings', 'menu.view')}">
				<menuitem label="{resourceManager.getString('obstrings', 'menu.showObjectList')}" type="check" data="viewShowObjectList"/>
			</menuitem>
			<menuitem label="{resourceManager.getString('obstrings', 'menu.tools')}">
				<menuitem label="{resourceManager.getString('obstrings', 'menu.toolsFindObject')}" data="toolsFind" icon="nail.objectbuilder.core.Icons_BINOCULARS"/>
				<menuitem label="{resourceManager.getString('obstrings', 'menu.toolsLookTypeGenerator')}" data="toolsLookGenerator" icon="nail.objectbuilder.core.Icons_OUTFIT"/>
			</menuitem>
			<menuitem label="{resourceManager.getString('obstrings', 'menu.window')}">
				<menuitem label="{resourceManager.getString('obstrings', 'menu.logWindow')}" data="windowOpenLog" icon="nail.objectbuilder.core.Icons_LOG"/>
			</menuitem>	
			<menuitem label="{resourceManager.getString('obstrings', 'menu.help')}">
				<menuitem label="{resourceManager.getString('obstrings', 'menu.about')}" data="helpAbout" icon="nail.objectbuilder.core.Icons_INFO"/>
			</menuitem>	
		</fx:XMLList>
	</fx:Declarations>
	
	<fx:Metadata>
		[ResourceBundle("strings")]
		[ResourceBundle("obstrings")]
	</fx:Metadata>
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.core.UIComponent;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.events.MenuEvent;
			import mx.managers.DragManager;
			
			import spark.events.IndexChangeEvent;
			
			import nail.assets.NailAssets;
			import nail.codecs.ImageCodec;
			import nail.codecs.ImageFormat;
			import nail.components.NailMain;
			import nail.components.controls.Alert;
			import nail.loaders.BitmapLoader;
			import nail.managers.PopUpWindowManager;
			import nail.objectbuilder.commands.ChangeThingCommand;
			import nail.objectbuilder.commands.CommandType;
			import nail.objectbuilder.commands.CompileAssetsCommand;
			import nail.objectbuilder.commands.CreateNewFilesCommand;
			import nail.objectbuilder.commands.DuplicateThingCommand;
			import nail.objectbuilder.commands.GetSpriteListCommand;
			import nail.objectbuilder.commands.GetThingCommand;
			import nail.objectbuilder.commands.GetThingListCommand;
			import nail.objectbuilder.commands.ImportSpriteCommand;
			import nail.objectbuilder.commands.ImportThingCommand;
			import nail.objectbuilder.commands.ImportThingFilesCommand;
			import nail.objectbuilder.commands.LoadAssetsCommand;
			import nail.objectbuilder.commands.NewThingCommand;
			import nail.objectbuilder.commands.ProgressBarID;
			import nail.objectbuilder.commands.RemoveSpritesCommand;
			import nail.objectbuilder.commands.RemoveThingCommand;
			import nail.objectbuilder.commands.ReplaceSpriteCommand;
			import nail.objectbuilder.settings.ObjectBuilderSettings;
			import nail.objectbuilder.utils.ObUtils;
			import nail.otlib.assets.AssetsInfo;
			import nail.otlib.assets.AssetsVersion;
			import nail.otlib.components.controls.CompileAssetsWindow;
			import nail.otlib.components.controls.CropImageWindow;
			import nail.otlib.components.controls.ExportWindow;
			import nail.otlib.components.controls.FindThingWindow;
			import nail.otlib.components.controls.ImportThingWindow;
			import nail.otlib.components.controls.LogWindow;
			import nail.otlib.components.controls.LookGenerator;
			import nail.otlib.components.controls.NewAssetsWindow;
			import nail.otlib.components.controls.OpenAssetsWindow;
			import nail.otlib.components.controls.PreferencesWindow;
			import nail.otlib.events.ThingEditorEvent;
			import nail.otlib.geom.Rect;
			import nail.otlib.things.ThingCategory;
			import nail.otlib.things.ThingType;
			import nail.otlib.utils.OTFormat;
			import nail.otlib.utils.SpriteData;
			import nail.otlib.utils.SpriteUtils;
			import nail.otlib.utils.ThingData;
			import nail.otlib.utils.ThingListItem;
			import nail.settings.Settings;
			import nail.utils.FileUtils;
			import nail.utils.SaveHelper;
			import nail.utils.StringUtil;
			import nail.utils.WindowUtils;
			import nail.workers.Command;
			
			//--------------------------------------------------------------------------
			//
			// PROPERTIES
			//
			//--------------------------------------------------------------------------
			
			private var _settings : ObjectBuilderSettings = new ObjectBuilderSettings();
			
			[Bindable]
			private var _thingsCollection : ArrayCollection = new ArrayCollection(); 
			
			[Bindable]
			private var _spritesCollection : ArrayCollection = new ArrayCollection(); 
			private var _thingData : ThingData;
			private var _nextThingData : ThingData;
			private var _thingDataChanged : Boolean;
			private var _filesName : String;
			
			[Bindable]
			private var _info : AssetsInfo;
			private var _selectThingIndex : int; 
			private var _thingMin : uint;
			private var _thingMax :uint;
			private var _selectSpriteIndex : int;
			private var _spriteMin : uint;
			private var _spriteMax :uint;
			private var _logText : String = "";
			private var _logWindow : LogWindow;
			private var _findThingWindow : FindThingWindow;
			private var _lookGenerator : LookGenerator;
			private var _autosave : Boolean;
			private var _autosaveChanged : Boolean;
			private var _showThingList : Boolean;
			private var _showThingListChanged : Boolean;
			
			//--------------------------------------------------------------------------
			//
			// METHODS
			//
			//--------------------------------------------------------------------------
			
			//--------------------------------------
			// Public
			//--------------------------------------
			
			public function setAssetsInfo(info:AssetsInfo) : void
			{
				var visible : Boolean;
				var version : AssetsVersion;
				
				_info = info;
				
				if (_info != null)
				{
					version = AssetsVersion.getVersionBySignatures(_info.datSignature, _info.sprSignature);
					assetsVersionLabel.text = version.toString();
					datSignatureLabel.text = _info.datSignature.toString(16).toUpperCase();
					itemsCountLabel.text = _info.maxItemId.toString();
					outfitsCountLabel.text  =_info.maxOutfitId.toString();
					effectsCountLabel.text = _info.maxEffectId.toString();
					missilesCountLabel.text = _info.maxMissileId.toString();
					sprSignatureLabel.text = _info.sprSignature.toString(16).toUpperCase();
					spritesCountLabel.text = _info.maxSpriteId.toString();
					thingStepper.minimum = getMinThingId();
					thingStepper.maximum = getMaxThingId();
					spriteStepper.minimum = _info.minSpriteId;
					spriteStepper.maximum = _info.maxSpriteId;
					
					if (_info.extended)
					{
						extendedValueLabel.text = resourceManager.getString("strings", "yes");
					}
					else 
					{
						extendedValueLabel.text = resourceManager.getString("strings", "no");
					}
				}
			}
			
			public function setThing(thing:ThingType, sprites:Vector.<SpriteData>) : void
			{
				if (thing == null) 
				{
					throw new ArgumentError("Parameter thing cannot be null.");
				}
				
				if (sprites == null) 
				{
					throw new ArgumentError("Parameter sprites cannot be null.");
				}
				
				this.thingData = new ThingData(thing, sprites);
			}
			
			public function setFindThingResultList(list:Array) : void
			{
				if (_findThingWindow != null)
				{
					_findThingWindow.setFindThingResultList(list);
				}
			}
			
			public function setFindThingProgress(loaded:uint, total:uint) : void
			{
				if (_findThingWindow != null)
				{
					_findThingWindow.setProgress(loaded, total)
				}
			}
			
			public function setThingList(target:uint, min:uint, max:uint, things:Vector.<ThingListItem>) : void
			{
				var length :uint;
				var i : int;
				var listItem : ThingListItem
				
				if (things == null)
				{
					throw new ArgumentError("Parameter things cannot be null.");
				}
				
				_thingsCollection.removeAll();
				_selectThingIndex = -1;
				_thingMin = min;
				_thingMax = max;
				thingAmountTextInput.text = min + " - " + max;
				
				length = things.length;
				for (i = 0; i < length; i++)
				{
					listItem = things[i];
					if (listItem == null)
					{
						throw new Error("Invalid Thing.");
					}
					
					_thingsCollection.addItem(listItem);
					
					if (listItem.thing.id == target)
					{
						_selectThingIndex = _thingsCollection.getItemIndex(listItem);
					}
				}
			}
			
			public function setSpriteList(target:uint, min:uint, max:uint, sprites:Vector.<SpriteData>) : void
			{
				var length :uint;
				var i : int;
				var sprite : SpriteData;
				
				if (sprites == null) 
				{
					throw new ArgumentError("Parameter sprites cannot be null.");
				}
				
				_spritesCollection.removeAll();
				_selectSpriteIndex = -1;
				_spriteMin = min;
				_spriteMax = max;
				
				length = sprites.length;
				for (i = 0; i < length; i++)
				{
					sprite = sprites[i];
					if (sprite == null)
					{
						throw new Error("Invalid sprite.");
					}
					
					_spritesCollection.addItem(sprite);
					
					if (sprite.id == target)
					{
						_selectSpriteIndex = _spritesCollection.getItemIndex(sprite);
					}
				}
			}
			
			public function appendLog(text:String) : void
			{
				if (text != null)
				{
					_logText += "&gt;&gt; " + text + "<br/>";
					
					if (_logWindow != null)
					{
						_logWindow.text = _logText;
					}
				}
			}
			
			public function saveThingChanges() : void
			{
				if (this.loaded &&
					this.thingData != null &&
					this.thingAttributes.changed)
				{
					if (this.thingAttributes.saveChanges())
					{
						sendCommand(new ChangeThingCommand(thingAttributes.thingData));
					}
				}
			}
			
			public function onOpenFile(defaultDirectory:File = null) : void
			{
				var window : OpenAssetsWindow;
				
				if (PopUpWindowManager.currentWindow is OpenAssetsWindow)
				{
					window = OpenAssetsWindow(PopUpWindowManager.currentWindow);
					window.directory = defaultDirectory || _settings.getLastDirectory();
				}
				else 
				{
					window = new OpenAssetsWindow();
					window.directory = defaultDirectory || _settings.getLastDirectory();
					window.addEventListener(Event.CLOSE, windowCloseHandler);
					window.open();
					
					PopUpWindowManager.addWindow(window);
				}
				
				function windowCloseHandler(event:Event) : void
				{
					_settings.setLastDirectory(window.datFile);
					
					if (window.datFile != null && window.sprFile != null && window.version != null)
					{
						_filesName = FileUtils.getName(window.datFile);
						loadAssets(window.datFile, window.sprFile, window.version, window.enableSpritesU32);
					}
				}
			}
			
			public function clear() : void
			{
				_thingData = null;
				_thingDataChanged = false
				_info = null;
				_nextThingData = null;
				_selectThingIndex = -1;
				_thingMax = 0;
				_thingMin = 0;
				_thingsCollection.removeAll();
				_selectSpriteIndex = -1;
				_spriteMax 0;
				_spriteMin 0;
				_spritesCollection.removeAll();
				
				editThing(null);
				thingView.thingData = null;
				assetsVersionLabel.text = null;
				datSignatureLabel.text = null;
				itemsCountLabel.text = null;
				outfitsCountLabel.text = null;
				effectsCountLabel.text = null;
				missilesCountLabel.text = null;
				sprSignatureLabel.text = null;
				spritesCountLabel.text = null;
				categoryDropDownList.selectedIndex = 0;
				thingStepper.value = 0;
				spriteStepper.value = 0;
				_logText = "";
			}
			
			//--------------------------------------
			// Override Public
			//--------------------------------------
			
			override public function getSettings() : Settings
			{
				return _settings;
			}
			
			//--------------------------------------
			// Override Protected
			//--------------------------------------
			
			override protected function commitProperties() : void
			{
				super.commitProperties();
				
				if (_thingDataChanged)
				{
					setThingData(_nextThingData);
					_nextThingData = null;
					_thingDataChanged = false;
				}
				
				if (_autosaveChanged)
				{
					menuXML[1].menuitem[0].@toggled = _autosave; // Edit > Autosave Changes
					_settings.autosaveThingChanges = _autosave;
					_autosaveChanged = false;
				}
				
				if (_showThingListChanged)
				{
					menuXML[2].menuitem[0].@toggled = _showThingList; // View > Show Object List
					thingListContainer.includeInLayout = _showThingList;
					showThingListButton.selected = _showThingList;
					_settings.showThingList = _showThingList;
					_showThingListChanged = false;
				}
			}
			
			override protected function createMenuDataProvider() : XMLList
			{
				return menuXML;
			}
			
			//--------------------------------------
			// Private
			//--------------------------------------
			
			private function loadAssets(dat:File, spr:File, version:AssetsVersion, enableSpritesU32:Boolean) : void
			{
				sendCommand(new LoadAssetsCommand(dat, spr, version, enableSpritesU32));
			}
			
			private function compileAssets(dat:File, spr:File, version:AssetsVersion, enableSpritesU32:Boolean) : void
			{
				if (this.autosave)
				{
					this.saveThingChanges();
				}
				
				sendCommand(new CompileAssetsCommand(dat, spr, version, enableSpritesU32));
			}
			
			private function onCreateNew() : void
			{
				var window : NewAssetsWindow;
				window = new NewAssetsWindow();
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler (event:Event) : void
				{
					if (window.version != null)
					{
						sendCommand(new CreateNewFilesCommand(window.version, window.enableSpritesU32));
					}
				}
			}
			
			private function onImportThingData(replace:ThingData = null) : void
			{
				var window : ImportThingWindow;
				
				if (!this.loaded)
				{
					return;
				}
				
				window = new ImportThingWindow();
				window.directory = _settings.getLastImportExportDirectory();
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					_settings.setLastImportExportDirectory(window.directory);
					
					if (window.thingData != null)
					{
						sendCommand(new ImportThingCommand(window.thingData, replace));
					}
				}
			}
			
			private function onExportThingData(fileName:String, format:String, directory:File, version:AssetsVersion, data:ThingData) : void
			{
				var bytes : ByteArray;
				var bitmap : BitmapData;
				var helper : SaveHelper;
				
				try
				{
					helper = new SaveHelper();
					
					if (ImageFormat.hasImageFormat(format))
					{
						bitmap = ThingData.getSpriteSheet(data);
						bytes = ImageCodec.encode(bitmap, format);
						helper.addFile(ObUtils.getPatternsString(data.thing), fileName, "txt", directory);
					}
					else if (format == OTFormat.OBD)
					{
						bytes = ThingData.serialize(data, version);
					}
					
					helper.addFile(bytes, fileName, format, directory);
					helper.save();
				} 
				catch(error:Error)
				{
					NailMain.instance.onError(error.message, error.getStackTrace(), error.errorID);
				}
			}
			
			private function onImportSprites(list:Vector.<BitmapData>) : void
			{
				var bitmap : BitmapData;
				var length : uint;
				var i :uint;
				var spritePixelsList : Vector.<ByteArray>;
				
				if (list == null || list.length == 0)
				{
					return;
				}
				
				length = list.length;
				if (length == 1)
				{
					bitmap = list[0];
					if (bitmap.width < 32 || bitmap.height < 32)
					{
						Alert.show(resourceManager.getString("obstrings", "invalidSpriteSize"),
							resourceManager.getString("obstrings", "importSprite"));
						return;
					}
					else if (bitmap.width == 32 && bitmap.height == 32)
					{
						bitmap = SpriteUtils.removeMagenta(bitmap);
						
						spritePixelsList = new Vector.<ByteArray>(length, true);
						spritePixelsList[0] = bitmap.getPixels(bitmap.rect);
						sendCommand(new ImportSpriteCommand(spritePixelsList));
					}
					else 
					{
						this.cropBitmap(bitmap);
					}
				}
				else
				{
					spritePixelsList = new Vector.<ByteArray>(length, true);
					
					for (i = 0; i < length; i++)
					{
						bitmap = list[i];
						if (bitmap.width != 32 || bitmap.height != 32)
						{
							Alert.show(resourceManager.getString("obstrings", "invalidSpriteSize"),
								resourceManager.getString("obstrings", "importSprite"));
							return;
						}
						
						bitmap = SpriteUtils.removeMagenta(bitmap);
						spritePixelsList[i] = bitmap.getPixels(bitmap.rect);
					}
					
					sendCommand(new ImportSpriteCommand(spritePixelsList));
				}
			}
			
			private function onExportSprites(fileName:String, format:String, directory:File, sprites:Vector.<SpriteData>) : void
			{
				var helper : SaveHelper;
				var length : uint;
				var i : uint;
				var spriteData : SpriteData;
				var bitmap : BitmapData;
				var bytes : ByteArray;
				var name : String;
				
				try
				{
					if (ImageFormat.hasImageFormat(format))
					{
						Main(NailMain.instance).onShowProgressBar(ProgressBarID.DEFAULT,
							resourceManager.getString("obstrings", "exportingSprites"));
							
						helper = new SaveHelper();
						helper.addEventListener(ProgressEvent.PROGRESS, progressHandler);
						helper.addEventListener(Event.COMPLETE, completeHandler);
						
						length = sprites.length;
						for (i = 0; i < length; i++)
						{
							spriteData = sprites[i];
							bitmap = spriteData.getBitmap(0xFFFF00FF);
							if (!SpriteUtils.isEmpty(bitmap))
							{
								bytes = ImageCodec.encode(bitmap, format);
								name = fileName + "_" + spriteData.id;
								helper.addFile(bytes, name, format, directory);
							}
						}
						
						helper.save();
					}
				} 
				catch(error:Error)
				{
					NailMain.instance.onError(error.message, error.getStackTrace(), error.errorID);
				}
				
				function progressHandler(event:ProgressEvent) : void
				{
					NailMain.instance.onProgress(ProgressBarID.DEFAULT, event.bytesLoaded, event.bytesTotal);
				}
				
				function completeHandler(event:Event) : void
				{
					Main(NailMain.instance).onHideProgressBar(ProgressBarID.DEFAULT);
				}
			}
			
			private function cropBitmap(bitmap:BitmapData) : void
			{
				var window : CropImageWindow;
				var bounds : Rectangle;
				
				window = new CropImageWindow();
				window.bitmap = bitmap;
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				// Centralize window.
				bounds = Screen.mainScreen.bounds;
				window.nativeWindow.x = (bounds.width - window.nativeWindow.width) * 0.5;
				window.nativeWindow.y = (bounds.height - window.nativeWindow.height) * 0.5;
				
				function windowCloseHandler(event:Event) : void
				{
					if (window.bitmapList != null)
					{
						onImportSprites(window.bitmapList);
					}
				}
			}
			
			private function selectSprite(id:uint) : void
			{
				var length :uint;
				var i : uint;
				var sprite : SpriteData;
				
				// Return if id is current selected.
				if (!this.loaded || this.spritesList.selectedSpriteId == id)
				{
					return;
				}
				
				// Search index if id is in range of loaded list.
				if (id >= _spriteMin && id <= _spriteMax)
				{
					length = _spritesCollection.length;
					for (i = 0; i < length; i++)
					{
						sprite = _spritesCollection.getItemAt(i) as SpriteData;
						if (sprite.id == id)
						{
							spritesList.selectedIndex = i;
							_selectSpriteIndex = i;
							spriteStepper.value = id;
							break;
						}
					}
				}
				else 
				{
					// Request new list by target id.
					sendCommand(new GetSpriteListCommand(id));
				}
			}
			
			private function onCompile() : void
			{
				var window : CompileAssetsWindow;
				
				if (!this.loaded)
				{
					return;
				}
				
				window = new CompileAssetsWindow();
				window.directory = _settings.getLastDirectory();
				window.version = AssetsVersion.getVersionBySignatures(_info.datSignature, _info.sprSignature);
				window.enableSpritesU32 = _info.extended;
				window.filesName = _filesName;
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					_settings.setLastDirectory(window.directory);
					
					if (window.datFile != null && window.sprFile != null && window.version != null)
					{
						compileAssets(window.datFile, window.sprFile, window.version, window.enableSpritesU32);
					}
				}
			}
			
			private function onCopySprite() : void
			{
				var data : SpriteData;
				var bitmap : BitmapData;
				
				if (!loaded)
				{
					return;
				}
				
				data = spritesList.selectedSprite;
				if (data != null)
				{
					bitmap = data.getBitmap(0xFFFF00FF);
					Clipboard.generalClipboard.clear();
					Clipboard.generalClipboard.setData(ClipboardFormats.BITMAP_FORMAT, bitmap);
				}
			}
			
			private function onPasteSprite() : void
			{
				var bitmap : BitmapData;
				var data : SpriteData;
				
				if (!loaded)
				{
					return;
				}
				
				if (Clipboard.generalClipboard.hasFormat(ClipboardFormats.BITMAP_FORMAT))
				{
					bitmap = BitmapData(Clipboard.generalClipboard.getData(ClipboardFormats.BITMAP_FORMAT));
					bitmap = SpriteUtils.removeMagenta(bitmap);
					
					if (bitmap.width == 32 && bitmap.height == 32)
					{
						data = spritesList.selectedSprite;
						if (data != null && spritesList.selectedSpriteId != 0)
						{
							sendCommand(new ReplaceSpriteCommand(data.id, bitmap));
						}
					}
					else 
					{
						this.cropBitmap(bitmap);
					}
				}
			}
			
			private function openLookGenerator() : void
			{
				if (_lookGenerator == null)
				{
					_lookGenerator = new LookGenerator();
					_lookGenerator.addEventListener(Event.CLOSE, lookGeneratorCloseHandler);
					_lookGenerator.open();
					
					WindowUtils.centralizeWindowOnScreen(_lookGenerator);
				}
				else 
				{
					_lookGenerator.activate();
				}
			}
			
			private function closeLookGenerator() : void
			{
				if (_lookGenerator!= null && !_lookGenerator.closed)
				{
					_lookGenerator.close();
				}
			}
			
			private function openLogWindow() : void
			{
				if (_logWindow == null)
				{
					_logWindow = new LogWindow();
					_logWindow.text = _logText;
					_logWindow.addEventListener(Event.CLOSE, logWindowCloseHandler);
					_logWindow.open();
					
					WindowUtils.centralizeWindowOnScreen(_logWindow);
				}
				else 
				{
					_logWindow.activate();
				}
			}
			
			private function closeLogWindow() : void
			{
				if (_logWindow!= null && !_logWindow.closed)
				{
					_logWindow.close();
				}
			}
			
			private function openPreferencesWindow() : void
			{
				var window : PreferencesWindow;
				window = new PreferencesWindow();
				window.settings = _settings;
				window.open();
				
				PopUpWindowManager.addWindow(window);
			}
			
			private function openFindThingWindow() : void
			{
				if (!loaded)
				{
					return;
				}
				
				if (_findThingWindow == null)
				{
					_findThingWindow = new FindThingWindow();
					_findThingWindow.addEventListener(Event.CLOSE, fingThingWindowCloseHandler);
					_findThingWindow.open();
					
					WindowUtils.centralizeWindowOnScreen(_findThingWindow);
				}
				else 
				{
					_findThingWindow.activate();
				}
			}
			
			private function closeFindThingWindow() : void
			{
				if (_findThingWindow!= null && !_findThingWindow.closed)
				{
					_findThingWindow.close();
				}
			}
			
			private function editThing(data:ThingData) : void
			{
				var visible : Boolean;
				
				thingAttributes.thingData = data;
				thingAttributes.visible = (data != null)
				confirmButton.enabled = thingAttributes.changed;
				cancelButton.enabled = (data != null);
				
				if (this.loaded && data != null)
				{
					// Hide unused controls to non-item objects.
					visible = (data.category == ThingCategory.ITEM);
					
					thingAttributes.groundGroupCheckBox.visible = visible;
					thingAttributes.groundGroupCheckBox.includeInLayout = visible;
					thingAttributes.automapGroupCheckBox.visible = visible;
					thingAttributes.automapGroupCheckBox.includeInLayout = visible;
					thingAttributes.hasElevationGroupCheckBox.visible = visible;
					thingAttributes.hasElevationGroupCheckBox.includeInLayout = visible;
					thingAttributes.equipGroupCheckBox.visible = visible;
					thingAttributes.equipGroupCheckBox.includeInLayout = visible;
					thingAttributes.writeReadGroupCheckBox.visible = visible;
					thingAttributes.writeReadGroupCheckBox.includeInLayout = visible;
					thingAttributes.flagsLeftColumn.visible = visible;
					thingAttributes.flagsLeftColumn.includeInLayout = visible;
					thingAttributes.pickupableCheckBox.visible = visible;
					thingAttributes.pickupableCheckBox.includeInLayout = visible;
					thingAttributes.pickupableCheckBox.visible = visible;
					thingAttributes.pickupableCheckBox.includeInLayout = visible;
					thingAttributes.hangableCheckBox.visible = visible;
					thingAttributes.hangableCheckBox.includeInLayout = visible;
					thingAttributes.horizontalCheckBox.visible = visible;
					thingAttributes.horizontalCheckBox.includeInLayout = visible;
					thingAttributes.verticalCheckBox.visible = visible;
					thingAttributes.verticalCheckBox.includeInLayout = visible;
					thingAttributes.rotatableCheckBox.visible = visible;
					thingAttributes.rotatableCheckBox.includeInLayout = visible;
					thingAttributes.dontHideCheckBox.visible = visible;
					thingAttributes.dontHideCheckBox.includeInLayout = visible;
					thingAttributes.translucentCheckBox.visible = visible;
					thingAttributes.translucentCheckBox.includeInLayout = visible;
					thingAttributes.isLyingObjectCheckBox.visible = visible;
					thingAttributes.isLyingObjectCheckBox.includeInLayout = visible;
					thingAttributes.fullGroundCheckBox.visible = visible;
					thingAttributes.fullGroundCheckBox.includeInLayout = visible;
					thingAttributes.ignoreLookCheckBox.visible = visible;
					thingAttributes.ignoreLookCheckBox.includeInLayout = visible;
					
					// Hide 'Market' GroupCheckBox.
					visible = (_info.version >= 940 && data.category == ThingCategory.ITEM);
					thingAttributes.marketGroupCheckBox.visible = visible;
					thingAttributes.marketGroupCheckBox.includeInLayout = visible;
					
					// Hide 'No Move Animation' CheckBox by version.
					visible = (_info.version >= 1010 && data.category == ThingCategory.ITEM);
					thingAttributes.noMoveAnimationCheckBox.visible = visible;
					thingAttributes.noMoveAnimationCheckBox.includeInLayout = visible;
					
					// Hide 'Action' GroupCheckBox and 'Usable' CheckBox by version.
					visible = (_info.version >= 1021 && data.category == ThingCategory.ITEM);
					thingAttributes.actionGroupCheckBox.visible = visible;
					thingAttributes.actionGroupCheckBox.includeInLayout = visible;
					thingAttributes.usableCheckBox.visible = visible;
					thingAttributes.usableCheckBox.includeInLayout = visible;
					
					// Charges, Floor Change, Equip and Translucent.
					visible = (_info.version <= 854 && data.category == ThingCategory.ITEM);
					thingAttributes.chargesCheckBox.visible = visible;
					thingAttributes.chargesCheckBox.includeInLayout = visible;
					thingAttributes.floorChangeCheckBox.visible = visible;
					thingAttributes.floorChangeCheckBox.includeInLayout = visible;
					
					if (_info.version <= 854)
					{
						thingAttributes.translucentCheckBox.visible = false;
						thingAttributes.translucentCheckBox.includeInLayout = false;
						thingAttributes.equipGroupCheckBox.visible = false;
						thingAttributes.equipGroupCheckBox.includeInLayout = false;
					}
				}
			}
			
			private function getCurrentCategory() : String
			{
				switch(categoryDropDownList.selectedIndex)
				{
					case 0:
						return ThingCategory.ITEM;
					case 1:
						return ThingCategory.OUTFIT;
					case 2:
						return ThingCategory.EFFECT;
					case 3:
						return ThingCategory.MISSILE;
				}
				return null;
			}
			
			private function getMinThingId() : uint
			{
				var category : String = getCurrentCategory();
				if (this.loaded && !isNullOrEmpty(category))
				{
					switch(category)
					{
						case ThingCategory.ITEM:
							return _info.minItemId;
						case ThingCategory.OUTFIT:
							return _info.minOutfitId;
						case ThingCategory.EFFECT:
							return _info.minEffectId;
						case ThingCategory.MISSILE:
							return _info.minMissileId;
					}
				}
				return 0;
			}
			
			private function getMaxThingId() : uint
			{
				var category : String = getCurrentCategory();
				if (this.loaded && !isNullOrEmpty(category))
				{
					switch(category) 
					{
						case ThingCategory.ITEM:
							return _info.maxItemId;
						case ThingCategory.OUTFIT:
							return _info.maxOutfitId;
						case ThingCategory.EFFECT:
							return _info.maxEffectId;
						case ThingCategory.MISSILE:
							return _info.maxMissileId;
					}
				}
				return 0;
			}
			
			private function setThingData(data:ThingData) : void
			{
				var id : uint;
				var length : uint;
				var i : uint;
				var listItem : ThingListItem;
				
				_thingData = data;
				thingView.thingData = data;
				
				if (data != null)
				{
					id = data.id;
					thingStepper.value = id;
					thingStepper.minimum = getMinThingId();
					thingStepper.maximum = getMaxThingId();
					
					if (thingAttributes.thingData != null && thingAttributes.thingData.id == id)
					{
						thingAttributes.thingData = data;
					}
					
					switch(data.category)
					{
						case ThingCategory.ITEM:
							categoryDropDownList.selectedIndex = 0;
							break;
							
						case ThingCategory.OUTFIT:
							categoryDropDownList.selectedIndex = 1;
							break;
						case ThingCategory.EFFECT:
							categoryDropDownList.selectedIndex = 2;
							break;
						
						case ThingCategory.MISSILE:
							categoryDropDownList.selectedIndex = 3;
							break;
					}
					
					// Search index if id is in range of loaded thing list.
					if (id >= _thingMin && id <= _thingMax)
					{
						length = _thingsCollection.length;
						for (i = 0; i < length; i++)
						{
							listItem = _thingsCollection.getItemAt(i) as ThingListItem;
							if (listItem.thing.id == id)
							{
								thingList.selectedIndex = i;
								_selectThingIndex = i;
								break;
							}
						}
					}
					else 
					{
						// Request new thing list by target id.
						sendCommand(new GetThingListCommand(id, data.category));
					}
				}
			}
			
			private function sendCommand(command:Command) : void
			{
				NailMain.instance.sendCommand(command);
			}
			
			private function saveWindowState() : void
			{
				_settings.previewContainerWidth = previewContainer.width;
				_settings.thingListContainerWidth = thingListContainer.width;
				_settings.spritesContainerWidth = spritesContainer.width;
				_settings.showThingList = showThingList;
			}
			
			//--------------------------------------
			// Event Handlers
			//--------------------------------------
			
			protected function confirmButtonClickHandler(event:MouseEvent) : void
			{
				if (thingAttributes.changed)
				{
					if (thingAttributes.saveChanges())
					{
						sendCommand(new ChangeThingCommand(thingAttributes.thingData));
					}
				}
			}
			
			protected function cancelButtonClickHandler(event:MouseEvent) : void
			{
				editThing(null);
			}
			
			protected function thingListUpdateCompleteHandler(event:FlexEvent) : void
			{
				if (_selectThingIndex != -1)
				{
					thingList.selectedIndex = _selectThingIndex;
					thingList.ensureIndexIsVisible(_selectThingIndex);
					thingStepper.value = this.thingList.selectedThingId;
				}
				_selectThingIndex = -1;
			}
			
			protected function thingListChangeHandler(event:IndexChangeEvent) : void
			{
				if (this.loaded && this.thingData != null)
				{
					if (thingList.selectedThingId != 0)
					{
						sendCommand(new GetThingCommand(thingList.selectedThingId, getCurrentCategory()));
					}
				}
			}
			
			protected function spriteListUpdateCompleteHandler(event:FlexEvent) : void
			{
				if (_selectSpriteIndex != -1)
				{
					spritesList.selectedIndex = _selectSpriteIndex;
					spritesList.ensureIndexIsVisible(_selectSpriteIndex);
					spriteStepper.value = this.spritesList.selectedSpriteId;
				}
				_selectSpriteIndex = -1;
			}
			
			override protected function creationCompleteHandler(event:FlexEvent) : void
			{
				super.creationCompleteHandler(event);
				
				this.autosave = _settings.autosaveThingChanges;
				
				if (_settings.maximized)
				{
					this.maximize();
				}
				
				previewContainer.width = Math.max(previewContainer.minWidth, _settings.previewContainerWidth);
				thingListContainer.width = Math.max(thingListContainer.minWidth, _settings.thingListContainerWidth);
				spritesContainer.width = Math.max(spritesContainer.minWidth, _settings.spritesContainerWidth);
				showThingList = _settings.showThingList;
			}
			
			override protected function menuItemClickHandler(event:MenuEvent) : void
			{
				var data : String = String(event.item.@data);
				
				switch(data) 
				{
					case "fileNew":
						this.onCreateNew();
						break;
					
					case "fileOpen":
						this.onOpenFile();
						break;
					
					case "fileCompile":
						this.onCompile();
						break;
					
					case "filePreferences":
						this.openPreferencesWindow();
						break;
					
					case "fileExit":
						this.close();
						break;
					
					case "viewShowObjectList":
						this.showThingList = !this.showThingList;
						break;
					
					case "editAutosave":
						this.autosave = !this.autosave;
						break;
					
					case "toolsFind":
						this.openFindThingWindow();
						break;
					
					case "toolsLookGenerator":
						this.openLookGenerator();
						break;
					
					case "windowOpenLog":
						this.openLogWindow();
						break;
					
					case "helpAbout":
						this.onAboutApplication();
						break;
				}
			}
			
			protected function categoryDropDownListChangeHandler(event:IndexChangeEvent) : void
			{
				if (this.loaded)
				{
					thingStepper.minimum = getMinThingId();
					thingStepper.maximum = getMaxThingId();
					thingStepper.value = thingStepper.minimum;
					sendCommand(new GetThingCommand(thingStepper.minimum, getCurrentCategory()));
					sendCommand(new GetThingListCommand(thingStepper.minimum, getCurrentCategory()));
				}
			}
			
			protected function thingChangedHandler(event:ThingEditorEvent) : void
			{
				var title : String = "";
				if (event.data != null)
				{
					title = ObUtils.toLocale(event.data.category) + " " + event.data.id;
				}
				
				this.updateTitle(title);
				
				confirmButton.enabled = false;
			}
			
			protected function thingPropertyChangedHandler(event:ThingEditorEvent) : void
			{
				var title : String = "";
				var message : String;
				
				if (event.data != null)
				{
					title = ObUtils.toLocale(event.data.category) + " " + event.data.id;
				}
				
				this.updateTitle(title, !thingAttributes.changed);
				
				confirmButton.enabled = thingAttributes.changed;
				
				if (event.property != null)
				{
					message = resourceManager.getString("obstrings", "propertyChanged");
					this.appendLog(StringUtil.substitute(message,
						ObUtils.toLocale(event.data.category),
						event.data.id,
						event.property,
						event.oldValue,
						event.newValue));
				}
			}
			
			protected function thingSpriteDoubleClickHandler(event:ThingEditorEvent) : void
			{
				selectSprite(event.sprite);
			}
			
			protected function thingStepperChangeHandler(event:Event) : void
			{
				if (this.loaded && this.thingData != null)
				{
					sendCommand(new GetThingCommand(thingStepper.value, getCurrentCategory()));
				}
			}
			
			protected function replaceThingHandler(event:Event) : void
			{
				this.onImportThingData(this.thingData);
			}
			
			protected function importThingHandler(event:Event) : void
			{
				this.onImportThingData();
			}
			
			protected function exportThingHandler(event:Event) : void
			{
				var window : ExportWindow;
				var version : AssetsVersion;
				
				if (!this.loaded || this.thingData == null)
				{
					return;
				}
				
				version = _settings.getLastExportThingVersion();
				if (version == null)
				{
					version = AssetsVersion.getVersionBySignatures(_info.datSignature, _info.sprSignature);
				}
				
				window = new ExportWindow();
				window.enableObdFormat = true;
				window.fileName = thingData.category + "_" + thingData.id;
				window.directory = _settings.getLastImportExportDirectory();
				window.format = _settings.getLastExportThingFormat();
				window.version = version;
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					if (window.fileName != null &&
						window.directory != null &&
						window.format != null)
					{
						_settings.setLastImportExportDirectory(window.directory);
						_settings.setLastExportThingFormat(window.format);
						_settings.setLastExportThingVersion(window.version);
						
						onExportThingData(window.fileName, window.format, window.directory, window.version, thingData);
					}
				}
			}
			
			protected function duplicateThingHandler(event:Event):void
			{
				if (this.loaded && this.thingData != null)
				{
					sendCommand(new DuplicateThingCommand(this.thingData));
				}
			}
			
			protected function editThingHandler(event:Event) : void
			{
				var message : String;
				
				if (!this.loaded || thingAttributes.thingData == this.thingData)
				{
					return;
				}
				
				if (this.autosave)
				{
					this.saveThingChanges();
				}
				
				if (thingAttributes.thingData != null && thingAttributes.changed)
				{
					message = StringUtil.substitute(resourceManager.getString("strings", "save"),
						ObUtils.toLocale(thingAttributes.thingData.category),
						thingAttributes.thingData.id);
					
					Alert.show(message,
						resourceManager.getString("controls", "label.info"),
						Alert.YES | Alert.NO | Alert.CANCEL,
						this,
						closeHandler);
					return;
				}
				
				editThing(thingData);
				
				function closeHandler(event:CloseEvent) : void
				{
					if (event.detail == Alert.YES)
					{
						saveThingChanges();
					}
					else if (event.detail == Alert.NO)
					{
						appendLog(StringUtil.substitute(resourceManager.getString("obstrings", "unsavedChanges"),
							ObUtils.toLocale(thingAttributes.thingData.category),
							thingAttributes.thingData.id));
					}
					else if (event.detail == Alert.CANCEL)
					{
						return
					}
					
					editThing(thingData);
				}
			}
			
			protected function newThingHandler(event:Event) : void
			{
				var category : String;
				
				if (this.loaded)
				{
					category = getCurrentCategory();
					if (category != null)
					{
						sendCommand(new NewThingCommand(category));
					}
				}
			}
			
			protected function removeThingHandler(event:Event) : void
			{
				var message : String;
				
				if (this.loaded && thingData != null)
				{
					message = StringUtil.substitute(resourceManager.getString("obstrings", "wantToRemove"),
						ObUtils.toLocale(thingData.category),
						thingData.id);
					
					Alert.show(message,
						resourceManager.getString("strings", "remove"),
						Alert.YES |  Alert.NO,
						this,
						alertCloseHandler);
				}
				
				function alertCloseHandler(event:CloseEvent) : void
				{
					if (event.detail == Alert.YES)
					{
						sendCommand(new RemoveThingCommand(thingData));
					}
				}
			}
			
			protected function thingDataNativeDragEnterHandler(event:NativeDragEvent) : void
			{
				if (loaded && event.target === thingViewGroup ||
					event.target === thingList)
				{
					if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
					{
						NativeDragManager.dropAction = NativeDragActions.LINK;
						DragManager.acceptDragDrop(UIComponent(event.target));
					}
				}
			}
			
			protected function thingDataNativeDragDropHandler(event:NativeDragEvent) : void
			{
				var clipboard : Clipboard;
				var dropfiles : Array;
				var length : uint;
				var file : File;
				var i : uint;
				var files : Array;
				
				if (!loaded)
				{
					return;
				}
				
				clipboard = event.clipboard;
				if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					dropfiles = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					length = dropfiles.length;
					files = [];
					
					for (i = 0; i < length; i++)
					{
						file = dropfiles[i];
						if (file.extension == OTFormat.OBD)
						{
							files.push(file.nativePath);
						}
					}
					
					if (files.length > 0)
					{
						sendCommand(new ImportThingFilesCommand(files));
					}
				}
			}
			
			protected function thingEditorDragEnterHandler(event:NativeDragEvent) : void
			{
				if (loaded && event.target === thingAttributes.buttonsContainer)
				{
					if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
					{
						NativeDragManager.dropAction = NativeDragActions.LINK;
						DragManager.acceptDragDrop(thingAttributes.buttonsContainer);
					}
				}
			}
			
			protected function thingEditorDragDropHandler(event:NativeDragEvent) : void
			{
				var clipboard : Clipboard;
				var file : File;
				var loader : BitmapLoader;
				
				if (!loaded)
				{
					return;
				}
				
				clipboard = event.clipboard;
				if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					file = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT)[0];
					if (FileUtils.hasBitmapFormat(file))
					{
						loader = new BitmapLoader();
						loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
						loader.load(file);
					}
				}
				
				function loadCompleteHandler(event:Event) : void
				{
					var thing : ThingType;
					var bitmap : BitmapData = loader.bitmap;
					var rect : nail.otlib.geom.Rect;
					var data : ThingData;
					var message : String;
					
					thing = thingAttributes.getThingTypeResult();
					rect = SpriteUtils.getSpriteSheetSize(thing);
					if (bitmap.width == rect.width && rect.height == bitmap.height)
					{
						data = ThingData.setSpriteSheet(bitmap, thing);
						if (data != null)
						{
							thingAttributes.thingData = data;
							confirmButton.enabled = true;
							thingAttributes.invalidateThingData();
						}
					}
					else 
					{
						message = resourceManager.getString("obstrings", "invalidSpriteSheetSize");
						Alert.show(StringUtil.substitute(message, rect.width, rect.height),
							resourceManager.getString("obstrings", "invalidSpriteSheetSizeTitle"));
					}
				}
			}
			
			protected function replaceSpriteHandler(event:Event) : void
			{
				var loader : BitmapLoader;
				
				if (!this.loaded || this.spritesList.selectedSpriteId == 0)
				{
					return;
				}
				
				loader = new BitmapLoader(_settings.getLastImportExportDirectory());
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.browseForOpen(resourceManager.getString("strings", "selectImage"));
				
				function completeHandler(event:Event) : void
				{
					var bitmap : BitmapData;
					var spriteData : SpriteData;
					
					bitmap = loader.bitmap;
					if (bitmap.width != 32 && bitmap.height != 32)
					{
						Alert.show(resourceManager.getString("obstrings", "invalidReplaceSize"),
							resourceManager.getString("obstrings", "replaceSprite"));
						return;
					}
					
					_settings.setLastImportExportDirectory(loader.directory);
					
					bitmap = SpriteUtils.removeMagenta(bitmap);
					
					spriteData = spritesList.selectedSprite;
					if (spriteData != null)
					{
						sendCommand(new ReplaceSpriteCommand(spriteData.id, bitmap));
					}
				}
			}
			
			protected function importSpriteButtonClickHandler(event:MouseEvent) : void
			{
				var loader : BitmapLoader;
				
				if (!this.loaded)
				{
					return;
				}
				
				Main(NailMain.instance).onShowProgressBar(ProgressBarID.DEFAULT,
					resourceManager.getString("obstrings", "loadingFiles"));
				
				loader = new BitmapLoader(_settings.getLastImportExportDirectory());
				loader.addEventListener(ProgressEvent.PROGRESS, progressHandler);
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.browseForOpenMultiple(resourceManager.getString("strings", "selectImages"));
				
				function progressHandler(event:ProgressEvent) : void
				{
					NailMain.instance.onProgress(ProgressBarID.DEFAULT, event.bytesLoaded, event.bytesTotal);
				}
				
				function completeHandler(event:Event) : void
				{
					_settings.setLastImportExportDirectory(loader.directory);
					Main(NailMain.instance).onHideProgressBar(ProgressBarID.DEFAULT);
					onImportSprites(loader.bitmapList);
				}
			}
			
			protected function exportSpriteHandler(event:Event) : void
			{
				var window : ExportWindow;
				
				if (!this.loaded || spritesList.selectedSprites.length == 0)
				{
					return;
				}
				
				window = new ExportWindow();
				window.fileName = "sprite";
				window.format = _settings.getLastExportSpriteFormat();
				window.directory = _settings.getLastImportExportDirectory();
				window.enableObdFormat = false;
				window.addEventListener(Event.CLOSE, windowCloseHandler);
				window.open();
				
				PopUpWindowManager.addWindow(window);
				
				function windowCloseHandler(event:Event) : void
				{
					if (window.fileName != null &&
						window.format != null &&
						window.directory != null)
					{
						_settings.setLastImportExportDirectory(window.directory);
						_settings.setLastExportSpriteFormat(window.format);
						
						onExportSprites(window.fileName, window.format, window.directory, spritesList.selectedSprites);
					}
				}
			}
			
			protected function newSpriteButtonClickHandler(event:MouseEvent) : void
			{
				if (this.loaded)
				{
					sendCommand(new Command(CommandType.NEW_SPRITE));
				}
			}
			
			protected function removeSpriteHandler(event:Event) : void
			{
				var sprites : Vector.<SpriteData>;
				var list : Vector.<uint>;
				var length : uint;
				var i : uint;
				
				if (!this.loaded)
				{
					return;
				}
				
				sprites = spritesList.selectedSprites;
				length = sprites.length;
				if (length > 0)
				{
					list = new Vector.<uint>(length, true);
					
					for (i = 0; i < length; i++)
					{
						list[i] = sprites[i].id;
					}
					
					list.sort(Array.NUMERIC | Array.DESCENDING);
					sendCommand(new RemoveSpritesCommand(list));
				}
			}
			
			protected function spritesListChangeHandler(event:IndexChangeEvent) : void
			{
				if (!this.loaded)
				{
					return;
				}
				
				spriteStepper.value = this.spritesList.selectedSpriteId;
				replaceSpriteButton.enabled = (spritesList.selectedSprites.length == 1);
			}
			
			protected function spriteStepperChangeHandler(event:Event) : void
			{
				if (this.loaded)
				{
					selectSprite(spriteStepper.value);
				}
			}
			
			protected function spritesListNativeDragEnterHandler(event:NativeDragEvent) : void
			{
				if (loaded && event.target === spritesList)
				{
					if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
					{
						NativeDragManager.dropAction = NativeDragActions.LINK;
						DragManager.acceptDragDrop(spritesList);
					}
				}
			}
			
			protected function spritesListNativeDragDropHandler(event:NativeDragEvent) : void
			{
				var clipboard : Clipboard;
				var dropfiles : Array;
				var length : uint;
				var i : uint;
				var files : Array;
				var loader : BitmapLoader;
				
				if (!loaded)
				{
					return;
				}
				
				clipboard = event.clipboard;
				if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					dropfiles = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					length = dropfiles.length;
					files = [];
					
					for (i = 0; i < length; i++)
					{
						files.push(dropfiles[i]);
					}
				}
				
				Main(NailMain.instance).onShowProgressBar(ProgressBarID.DEFAULT,
					resourceManager.getString("obstrings", "loadingFiles"));
				
				loader = new BitmapLoader();
				loader.addEventListener(ProgressEvent.PROGRESS, progressHandler);
				loader.addEventListener(Event.COMPLETE, completeHandler);
				loader.loadFiles(files);
				
				function progressHandler(event:ProgressEvent) : void
				{
					NailMain.instance.onProgress(ProgressBarID.DEFAULT, event.bytesLoaded, event.bytesTotal);
				}
				
				function completeHandler(event:Event) : void
				{
					Main(NailMain.instance).onHideProgressBar(ProgressBarID.DEFAULT);
					onImportSprites(loader.bitmapList);
				}
			}
			
			protected function lookGeneratorCloseHandler(event:Event) : void
			{
				_lookGenerator.removeEventListener(Event.CLOSE, logWindowCloseHandler);
				_lookGenerator = null;
			}
			
			protected function logWindowCloseHandler(event:Event) : void
			{
				_logWindow.removeEventListener(Event.CLOSE, logWindowCloseHandler);
				_logWindow = null;
			}
			
			protected function fingThingWindowCloseHandler(event:Event) : void
			{
				_findThingWindow.removeEventListener(Event.CLOSE, logWindowCloseHandler);
				_findThingWindow = null;
			}
			
			protected function previusAmountButtonDownHandler(event:FlexEvent) : void
			{
				var target : uint;
				
				if (loaded && thingData != null)
				{
					target = Math.max(getMinThingId(), ObUtils.hundredFloor(thingData.id) - 100);
					if (target < _thingMin)
					{
						sendCommand(new GetThingCommand(target, getCurrentCategory()));
					}
				}
			}
			
			protected function nextAmountButtonDownHandler(event:FlexEvent) : void
			{
				var target : uint;
				
				if (loaded && thingData != null)
				{
					target = Math.min(getMaxThingId(), ObUtils.hundredFloor(thingData.id) + 100);
					if (target > _thingMax)
					{
						sendCommand(new GetThingCommand(target, getCurrentCategory()));
					}
				}
			}
			
			protected function applicationDisplayStateChangeHandler(event:NativeWindowDisplayStateEvent) : void
			{
				if (_settings != null)
				{
					_settings.maximized = event.afterDisplayState == NativeWindowDisplayState.MAXIMIZED;
				}
			}
			
			protected function applicationClosingHandler(event:Event) : void
			{
				this.closeLogWindow();
				this.closeFindThingWindow();
				this.closeLookGenerator();
				this.saveWindowState();
				
				if (loaded && !NailMain.instance.getSharedProperty("compiled"))
				{
					event.preventDefault();
					Alert.show(resourceManager.getString("obstrings", "wantToCompile"), "", Alert.YES | Alert.NO | Alert.CANCEL, this, alertCloseHandler);
				}
				
				function alertCloseHandler(event:CloseEvent) : void
				{
					if (event.detail == Alert.YES)
					{
						onCompile();
					}
					else if (event.detail == Alert.NO)
					{
						NailMain.instance.exit();
					}
				}
			}
			
			//--------------------------------------
			// Getters / Setters 
			//--------------------------------------
			
			public function get loaded() : Boolean
			{
				return (_info != null);
			}
			
			public function get thingData() : ThingData
			{
				return _thingData;
			}
			
			public function set thingData(value:ThingData) : void
			{
				if (_thingData != value)
				{
					_nextThingData = value;
					_thingDataChanged = true;
					invalidateProperties();
				}
			}
			
			public function get autosave() : Boolean
			{
				return _autosave;
			}
			
			public function set autosave(value:Boolean) : void
			{
				if (_autosave != value)
				{
					_autosave = value;
					_autosaveChanged = true;
					invalidateProperties();
				}
			}
			
			public function get showThingList() : Boolean
			{
				return _showThingList;
			}
			
			public function set showThingList(value:Boolean) : void
			{
				if (_showThingList != value)
				{
					_showThingList = value;
					_showThingListChanged = true;
					invalidateProperties();
				}
			}
			
		]]>
	</fx:Script>
	
	<nail:toolBar>
		<s:HGroup width="100%"
				  height="100%"
				  verticalAlign="middle"
				  paddingLeft="10"
				  paddingRight="10">
			<s:Button width="25"
					  height="25"
					  toolTip="{resourceManager.getString('obstrings', 'menu.new')}"
					  icon="{Icons.NEW_FILES_WHITE}"
					  click="onCreateNew()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<s:Button width="25"
					  height="25"
					  toolTip="{resourceManager.getString('obstrings', 'menu.open')}"
					  icon="{Icons.OPEN_WHITE}"
					  click="onOpenFile()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<s:Button width="25"
					  height="25"
					  toolTip="{resourceManager.getString('obstrings', 'menu.compile')}"
					  icon="{Icons.SAVE_WHITE}"
					  click="onCompile()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<nail:ShadowLine height="20"/>
			<s:Button width="25"
					  height="25"
					  toolTip="{resourceManager.getString('obstrings', 'menu.toolsFindObject')}"
					  icon="{Icons.BINOCULARS_WHITE}"
					  click="openFindThingWindow()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
			<nail:ShadowLine height="20"/>
			<s:Button width="25"
					  height="25"
					  toolTip="{resourceManager.getString('obstrings', 'menu.logWindow')}"
					  icon="{Icons.LOG_WHITE}"
					  click="openLogWindow()"
					  skinClass="nail.components.skins.IconButtonSkin"/>
		</s:HGroup>
	</nail:toolBar>
	
	<mx:HDividedBox width="100%"
					height="100%">
		
		<!-- Info/View Container -->
		<s:BorderContainer id="previewContainer"
						   minWidth="165"
						   maxWidth="280"
						   width="165"
						   height="100%"
						   fontSize="11"
						   skinClass="nail.components.skins.BorderContainerSkin">
			<s:layout>
				<s:VerticalLayout horizontalAlign="center"
								  paddingRight="5"
								  paddingLeft="5"
								  paddingTop="10"
								  paddingBottom="10"
								  gap="10"/>
			</s:layout>
			
			<nail:GroupBox label="Info"
						   width="100%"
						   fontSize="10">
				<nail:layout>
					<s:TileLayout verticalGap="3"
								  requestedColumnCount="2"
								  paddingLeft="5"
								  paddingRight="5"
								  paddingTop="10"
								  paddingBottom="10"/>
				</nail:layout>
				<s:Label text="{resourceManager.getString('strings', 'version') + ':'}"/>
				<s:Label id="assetsVersionLabel"/>
				<s:Label text="Dat:"/>
				<s:RichEditableText id="datSignatureLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="{resourceManager.getString('strings', 'items') + ':'}"/>
				<s:RichEditableText id="itemsCountLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="{resourceManager.getString('strings', 'outfits') + ':'}"/>
				<s:RichEditableText id="outfitsCountLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="{resourceManager.getString('strings', 'effects') + ':'}"/>
				<s:RichEditableText id="effectsCountLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="{resourceManager.getString('strings', 'missiles') + ':'}"/>
				<s:RichEditableText id="missilesCountLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="Spr:"/>
				<s:RichEditableText id="sprSignatureLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="{resourceManager.getString('strings', 'sprites') + ':'}"/>
				<s:RichEditableText id="spritesCountLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
				<s:Label text="{resourceManager.getString('strings', 'extended') + ':'}"/>
				<s:RichEditableText id="extendedValueLabel"
									editable="false"
									focusEnabled="false"
									height="13"/>
			</nail:GroupBox>
			
			<nail:ShadowLine width="100%"/>
			
			<s:HGroup width="100%"
					  height="22">
				<s:DropDownList id="categoryDropDownList"
								selectedIndex="0"
								width="100%"
								height="20"
								change="categoryDropDownListChangeHandler(event)">
					<s:dataProvider>
						<s:ArrayList>
							<fx:String>{resourceManager.getString('strings', 'item')}</fx:String>
							<fx:String>{resourceManager.getString('strings', 'outfit')}</fx:String>
							<fx:String>{resourceManager.getString('strings', 'effect')}</fx:String>
							<fx:String>{resourceManager.getString('strings', 'missile')}</fx:String>
						</s:ArrayList>
					</s:dataProvider>
				</s:DropDownList>
				<s:ToggleButton id="showThingListButton"
								toolTip="@Resource(key='showObjectList', bundle='obstrings')"
								width="20"
								height="20"
								icon="{Icons.SHOW_LIST_ICON}"
								change="{showThingList = showThingListButton.selected}"/>
			</s:HGroup>
			
			<nail:GroupBox id="thingViewGroup"
						   label="@Resource(key='preview', bundle='strings')"
						   width="100%"
						   height="100%"
						   nativeDragEnter="thingDataNativeDragEnterHandler(event)"
						   nativeDragDrop="thingDataNativeDragDropHandler(event)">
				<otlib:ThingView id="thingView"
								 horizontalCenter="0"
								 verticalCenter="0"/>
			</nail:GroupBox>
			
			<nail:XNumericStepper id="thingStepper"
								  width="100%"
								  fontSize="11"
								  change="thingStepperChangeHandler(event)"/>
			
			<s:HGroup width="100%"
					  horizontalAlign="center"
					  verticalAlign="middle"
					  gap="3">
				<s:Button id="replaceThingButton"
						  toolTip="@Resource(key='replace', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.REPLACE}"
						  click="replaceThingHandler(event)"/>
				<s:Button id="importThingButton"
						  toolTip="@Resource(key='import', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.IMPORT}"
						  click="importThingHandler(event)"/>
				<s:Button id="exportThingButton"
						  toolTip="@Resource(key='export', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.EXPORT}"
						  click="exportThingHandler(event)"/>
				<s:Button id="editThingButton"
						  toolTip="@Resource(key='edit', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.EDIT}"
						  click="editThingHandler(event)"/>
				<s:Button id="duplicateThingButton"
						  toolTip="@Resource(key='duplicate', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.DUPLICATE}"
						  click="duplicateThingHandler(event)"/>
				<s:Button id="newThingButton"
						  toolTip="@Resource(key='new', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.NEW}"
						  click="newThingHandler(event)"/>
				<s:Button id="removeThingButton"
						  toolTip="@Resource(key='remove', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.DELETE}"
						  click="removeThingHandler(event)"/>
			</s:HGroup>
		</s:BorderContainer>
		
		<!-- Thing List Container -->
		<s:BorderContainer id="thingListContainer"
						   minWidth="165"
						   maxWidth="280"
						   width="165"
						   height="100%"
						   fontSize="11"
						   includeInLayout="false"
						   skinClass="nail.components.skins.BorderContainerSkin">
			<s:layout>
				<s:VerticalLayout horizontalAlign="center"
								  paddingRight="5"
								  paddingLeft="5"
								  paddingTop="10"
								  paddingBottom="10"
								  gap="10"/>
			</s:layout>
			
			<otlib:ThingList id="thingList"
							 width="100%"
							 height="100%"
							 dataProvider="{_thingsCollection}"
							 fontSize="11"
							 borderAlpha="0"
							 doubleClickEnabled="true"
							 replace="replaceThingHandler(event)"
							 export="exportThingHandler(event)"
							 duplicate="duplicateThingHandler(event)"
							 edit="editThingHandler(event)"
							 remove="removeThingHandler(event)"
							 doubleClick="editThingHandler(event)"
							 change="thingListChangeHandler(event)"
							 nativeDragEnter="thingDataNativeDragEnterHandler(event)"
							 nativeDragDrop="thingDataNativeDragDropHandler(event)"
							 updateComplete="thingListUpdateCompleteHandler(event)"/>
			
			<s:HGroup width="100%"
					  horizontalAlign="center"
					  verticalAlign="middle"
					  gap="1">
				<s:Button id="previusAmountButton"
						  width="20"
						  height="20"
						  autoRepeat="true"
						  repeatInterval="300"
						  icon="{NailAssets.PREVIOUS}"
						  buttonDown="previusAmountButtonDownHandler(event)"/>
				<s:TextInput id="thingAmountTextInput"
							 width="100%"
							 height="20"
							 editable="false"
							 textAlign="center"
							 skinClass="nail.components.skins.NumericStepperTextInputSkin"/>
				<s:Button id="nextAmountButton"
						  width="20"
						  height="20"
						  autoRepeat="true"
						  repeatInterval="300"
						  icon="{NailAssets.NEXT}"
						  buttonDown="nextAmountButtonDownHandler(event)"/>
			</s:HGroup>
		</s:BorderContainer>
		
		<!-- ThingType Editor Group -->
		<s:Group minWidth="310"
				 width="100%"
				 height="100%">
			<s:layout>
				<s:VerticalLayout gap="-1"/>
			</s:layout>
			
			<s:BorderContainer width="100%"
							   height="100%"
							   skinClass="nail.components.skins.BorderContainerSkin">
				<otlib:ThingTypeEditor id="thingAttributes"
									   width="100%"
									   height="100%"
									   visible="false"
									   thingChange="thingChangedHandler(event)"
									   thingPropertyChange="thingPropertyChangedHandler(event)"
									   spriteDoubleClick="thingSpriteDoubleClickHandler(event)"
									   nativeDragEnter="thingEditorDragEnterHandler(event)"
									   nativeDragDrop="thingEditorDragDropHandler(event)"/>
			</s:BorderContainer>
			
			<s:BorderContainer width="100%"
							   backgroundColor="0x535353"
							   borderColor="0x272727">
				<s:layout>
					<s:HorizontalLayout horizontalAlign="right"
										verticalAlign="middle"
										paddingLeft="10"
										paddingRight="10"
										paddingTop="3"
										paddingBottom="3"/>
				</s:layout>
				<s:Button id="confirmButton"
						  label="@Resource(key='save', bundle='strings')"
						  fontSize="11"
						  height="20"
						  enabled="false"
						  click="confirmButtonClickHandler(event)"/>
				<s:Button id="cancelButton"
						  label="@Resource(key='close', bundle='strings')" 
						  fontSize="11"
						  height="20"
						  enabled="false"
						  click="cancelButtonClickHandler(event)"/>
			</s:BorderContainer>
		</s:Group>
		
		<!-- Sprites Container -->
		<s:BorderContainer id="spritesContainer"
						   minWidth="165"
						   maxWidth="250"
						   width="165"
						   height="100%"
						   skinClass="nail.components.skins.BorderContainerSkin">
			<s:layout>
				<s:VerticalLayout horizontalAlign="center"
								  paddingRight="5"
								  paddingLeft="5"
								  paddingTop="10"
								  paddingBottom="10"
								  gap="10"/>
			</s:layout>	
			
			<nail:GroupBox label="Sprites"
						   width="100%"
						   height="100%">
				<nail:layout>
					<s:VerticalLayout paddingRight="0"
									  paddingLeft="0"
									  paddingTop="10"
									  paddingBottom="0"/>
				</nail:layout>
				<otlib:SpriteList id="spritesList" 
								  width="100%"
								  height="100%"
								  dataProvider="{_spritesCollection}"
								  allowMultipleSelection="true"
								  dragEnabled="true"
								  fontSize="11"
								  borderAlpha="0"
								  focusEnabled="false"
								  change="spritesListChangeHandler(event)"
								  updateComplete="spriteListUpdateCompleteHandler(event)"
								  copy="onCopySprite()"
								  paste="onPasteSprite()"
								  replace="replaceSpriteHandler(event)"
								  export="exportSpriteHandler(event)"
								  remove="removeSpriteHandler(event)"
								  nativeDragEnter="spritesListNativeDragEnterHandler(event)"
								  nativeDragDrop="spritesListNativeDragDropHandler(event)"/>
			</nail:GroupBox>
			
			<nail:XNumericStepper id="spriteStepper"
								  width="100%"
								  fontSize="11"
								  change="spriteStepperChangeHandler(event)"/>
			
			<s:HGroup width="100%"
					  horizontalAlign="right"
					  verticalAlign="middle"
					  gap="3">
				<s:Button id="replaceSpriteButton"
						  toolTip="@Resource(key='replace', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.REPLACE}"
						  click="replaceSpriteHandler(event)"/>
				<s:Button id="importSpriteButton"
						  toolTip="@Resource(key='import', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.IMPORT}"
						  click="importSpriteButtonClickHandler(event)"/>
				<s:Button id="exportSpriteButton"
						  toolTip="@Resource(key='export', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.EXPORT}"
						  click="exportSpriteHandler(event)"/>
				<s:Button id="copySpriteButton"
						  toolTip="@Resource(key='copy', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.COPY}"
						  click="onCopySprite()"/>
				<s:Button id="pasteSpriteButton"
						  toolTip="@Resource(key='paste', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.PASTE}"
						  click="onPasteSprite()"/>
				<s:Button id="newSpriteButton"
						  toolTip="@Resource(key='new', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.NEW}"
						  click="newSpriteButtonClickHandler(event)"/>
				<s:Button id="removeSpriteButton"
						  toolTip="@Resource(key='remove', bundle='strings')"
						  minWidth="19"
						  width="100%"
						  height="19"
						  icon="{Icons.DELETE}"
						  click="removeSpriteHandler(event)"/>
			</s:HGroup>
		</s:BorderContainer>
	</mx:HDividedBox>
</nail:NailApplication>
